{"version":3,"file":"268.js","mappings":"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","sources":["webpack://@lenna-proj/lenna-web/./node_modules/@vue/devtools-api/lib/esm/env.js","webpack://@lenna-proj/lenna-web/./node_modules/@vue/devtools-api/lib/esm/time.js","webpack://@lenna-proj/lenna-web/./node_modules/@vue/devtools-api/lib/esm/proxy.js","webpack://@lenna-proj/lenna-web/./node_modules/@vue/devtools-api/lib/esm/const.js","webpack://@lenna-proj/lenna-web/./node_modules/vue-router/dist/vue-router.esm-bundler.js","webpack://@lenna-proj/lenna-web/./node_modules/@vue/devtools-api/lib/esm/index.js"],"sourcesContent":["export function getDevtoolsGlobalHook() {\n    return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;\n}\nexport function getTarget() {\n    // @ts-ignore\n    return (typeof navigator !== 'undefined' && typeof window !== 'undefined')\n        ? window\n        : typeof global !== 'undefined'\n            ? global\n            : {};\n}\nexport const isProxyAvailable = typeof Proxy === 'function';\n","let supported;\nlet perf;\nfunction isSupported() {\n    if (supported !== undefined) {\n        return supported;\n    }\n    if (typeof window !== 'undefined' && window.performance) {\n        supported = true;\n        perf = window.performance;\n    }\n    else {\n        supported = false;\n    }\n    return supported;\n}\nexport function now() {\n    return isSupported() ? perf.now() : Date.now();\n}\n","import { HOOK_PLUGIN_SETTINGS_SET } from './const';\nimport { now } from './time';\nexport class ApiProxy {\n    constructor(plugin, hook) {\n        this.target = null;\n        this.targetQueue = [];\n        this.onQueue = [];\n        this.plugin = plugin;\n        this.hook = hook;\n        const defaultSettings = {};\n        if (plugin.settings) {\n            for (const id in plugin.settings) {\n                const item = plugin.settings[id];\n                defaultSettings[id] = item.defaultValue;\n            }\n        }\n        const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;\n        let currentSettings = Object.assign({}, defaultSettings);\n        try {\n            const raw = localStorage.getItem(localSettingsSaveId);\n            const data = JSON.parse(raw);\n            Object.assign(currentSettings, data);\n        }\n        catch (e) {\n            // noop\n        }\n        this.fallbacks = {\n            getSettings() {\n                return currentSettings;\n            },\n            setSettings(value) {\n                try {\n                    localStorage.setItem(localSettingsSaveId, JSON.stringify(value));\n                }\n                catch (e) {\n                    // noop\n                }\n                currentSettings = value;\n            },\n            now() {\n                return now();\n            },\n        };\n        if (hook) {\n            hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {\n                if (pluginId === this.plugin.id) {\n                    this.fallbacks.setSettings(value);\n                }\n            });\n        }\n        this.proxiedOn = new Proxy({}, {\n            get: (_target, prop) => {\n                if (this.target) {\n                    return this.target.on[prop];\n                }\n                else {\n                    return (...args) => {\n                        this.onQueue.push({\n                            method: prop,\n                            args,\n                        });\n                    };\n                }\n            },\n        });\n        this.proxiedTarget = new Proxy({}, {\n            get: (_target, prop) => {\n                if (this.target) {\n                    return this.target[prop];\n                }\n                else if (prop === 'on') {\n                    return this.proxiedOn;\n                }\n                else if (Object.keys(this.fallbacks).includes(prop)) {\n                    return (...args) => {\n                        this.targetQueue.push({\n                            method: prop,\n                            args,\n                            resolve: () => { },\n                        });\n                        return this.fallbacks[prop](...args);\n                    };\n                }\n                else {\n                    return (...args) => {\n                        return new Promise(resolve => {\n                            this.targetQueue.push({\n                                method: prop,\n                                args,\n                                resolve,\n                            });\n                        });\n                    };\n                }\n            },\n        });\n    }\n    async setRealTarget(target) {\n        this.target = target;\n        for (const item of this.onQueue) {\n            this.target.on[item.method](...item.args);\n        }\n        for (const item of this.targetQueue) {\n            item.resolve(await this.target[item.method](...item.args));\n        }\n    }\n}\n","export const HOOK_SETUP = 'devtools-plugin:setup';\nexport const HOOK_PLUGIN_SETTINGS_SET = 'plugin:settings:set';\n","/*!\n  * vue-router v4.0.14\n  * (c) 2022 Eduardo San Martin Morote\n  * @license MIT\n  */\nimport { getCurrentInstance, inject, onUnmounted, onDeactivated, onActivated, computed, unref, watchEffect, defineComponent, reactive, h, provide, ref, watch, shallowRef, nextTick } from 'vue';\nimport { setupDevtoolsPlugin } from '@vue/devtools-api';\n\nconst hasSymbol = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\r\nconst PolySymbol = (name) => \r\n// vr = vue router\r\nhasSymbol\r\n    ? Symbol((process.env.NODE_ENV !== 'production') ? '[vue-router]: ' + name : name)\r\n    : ((process.env.NODE_ENV !== 'production') ? '[vue-router]: ' : '_vr_') + name;\r\n// rvlm = Router View Location Matched\r\n/**\r\n * RouteRecord being rendered by the closest ancestor Router View. Used for\r\n * `onBeforeRouteUpdate` and `onBeforeRouteLeave`. rvlm stands for Router View\r\n * Location Matched\r\n *\r\n * @internal\r\n */\r\nconst matchedRouteKey = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'router view location matched' : 'rvlm');\r\n/**\r\n * Allows overriding the router view depth to control which component in\r\n * `matched` is rendered. rvd stands for Router View Depth\r\n *\r\n * @internal\r\n */\r\nconst viewDepthKey = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'router view depth' : 'rvd');\r\n/**\r\n * Allows overriding the router instance returned by `useRouter` in tests. r\r\n * stands for router\r\n *\r\n * @internal\r\n */\r\nconst routerKey = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'router' : 'r');\r\n/**\r\n * Allows overriding the current route returned by `useRoute` in tests. rl\r\n * stands for route location\r\n *\r\n * @internal\r\n */\r\nconst routeLocationKey = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'route location' : 'rl');\r\n/**\r\n * Allows overriding the current route used by router-view. Internally this is\r\n * used when the `route` prop is passed.\r\n *\r\n * @internal\r\n */\r\nconst routerViewLocationKey = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'router view location' : 'rvl');\n\nconst isBrowser = typeof window !== 'undefined';\n\nfunction isESModule(obj) {\r\n    return obj.__esModule || (hasSymbol && obj[Symbol.toStringTag] === 'Module');\r\n}\r\nconst assign = Object.assign;\r\nfunction applyToParams(fn, params) {\r\n    const newParams = {};\r\n    for (const key in params) {\r\n        const value = params[key];\r\n        newParams[key] = Array.isArray(value) ? value.map(fn) : fn(value);\r\n    }\r\n    return newParams;\r\n}\r\nconst noop = () => { };\n\nfunction warn(msg) {\r\n    // avoid using ...args as it breaks in older Edge builds\r\n    const args = Array.from(arguments).slice(1);\r\n    console.warn.apply(console, ['[Vue Router warn]: ' + msg].concat(args));\r\n}\n\nconst TRAILING_SLASH_RE = /\\/$/;\r\nconst removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, '');\r\n/**\r\n * Transforms an URI into a normalized history location\r\n *\r\n * @param parseQuery\r\n * @param location - URI to normalize\r\n * @param currentLocation - current absolute location. Allows resolving relative\r\n * paths. Must start with `/`. Defaults to `/`\r\n * @returns a normalized history location\r\n */\r\nfunction parseURL(parseQuery, location, currentLocation = '/') {\r\n    let path, query = {}, searchString = '', hash = '';\r\n    // Could use URL and URLSearchParams but IE 11 doesn't support it\r\n    const searchPos = location.indexOf('?');\r\n    const hashPos = location.indexOf('#', searchPos > -1 ? searchPos : 0);\r\n    if (searchPos > -1) {\r\n        path = location.slice(0, searchPos);\r\n        searchString = location.slice(searchPos + 1, hashPos > -1 ? hashPos : location.length);\r\n        query = parseQuery(searchString);\r\n    }\r\n    if (hashPos > -1) {\r\n        path = path || location.slice(0, hashPos);\r\n        // keep the # character\r\n        hash = location.slice(hashPos, location.length);\r\n    }\r\n    // no search and no query\r\n    path = resolveRelativePath(path != null ? path : location, currentLocation);\r\n    // empty path means a relative query or hash `?foo=f`, `#thing`\r\n    return {\r\n        fullPath: path + (searchString && '?') + searchString + hash,\r\n        path,\r\n        query,\r\n        hash,\r\n    };\r\n}\r\n/**\r\n * Stringifies a URL object\r\n *\r\n * @param stringifyQuery\r\n * @param location\r\n */\r\nfunction stringifyURL(stringifyQuery, location) {\r\n    const query = location.query ? stringifyQuery(location.query) : '';\r\n    return location.path + (query && '?') + query + (location.hash || '');\r\n}\r\n/**\r\n * Strips off the base from the beginning of a location.pathname in a non\r\n * case-sensitive way.\r\n *\r\n * @param pathname - location.pathname\r\n * @param base - base to strip off\r\n */\r\nfunction stripBase(pathname, base) {\r\n    // no base or base is not found at the beginning\r\n    if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))\r\n        return pathname;\r\n    return pathname.slice(base.length) || '/';\r\n}\r\n/**\r\n * Checks if two RouteLocation are equal. This means that both locations are\r\n * pointing towards the same {@link RouteRecord} and that all `params`, `query`\r\n * parameters and `hash` are the same\r\n *\r\n * @param a - first {@link RouteLocation}\r\n * @param b - second {@link RouteLocation}\r\n */\r\nfunction isSameRouteLocation(stringifyQuery, a, b) {\r\n    const aLastIndex = a.matched.length - 1;\r\n    const bLastIndex = b.matched.length - 1;\r\n    return (aLastIndex > -1 &&\r\n        aLastIndex === bLastIndex &&\r\n        isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) &&\r\n        isSameRouteLocationParams(a.params, b.params) &&\r\n        stringifyQuery(a.query) === stringifyQuery(b.query) &&\r\n        a.hash === b.hash);\r\n}\r\n/**\r\n * Check if two `RouteRecords` are equal. Takes into account aliases: they are\r\n * considered equal to the `RouteRecord` they are aliasing.\r\n *\r\n * @param a - first {@link RouteRecord}\r\n * @param b - second {@link RouteRecord}\r\n */\r\nfunction isSameRouteRecord(a, b) {\r\n    // since the original record has an undefined value for aliasOf\r\n    // but all aliases point to the original record, this will always compare\r\n    // the original record\r\n    return (a.aliasOf || a) === (b.aliasOf || b);\r\n}\r\nfunction isSameRouteLocationParams(a, b) {\r\n    if (Object.keys(a).length !== Object.keys(b).length)\r\n        return false;\r\n    for (const key in a) {\r\n        if (!isSameRouteLocationParamsValue(a[key], b[key]))\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\nfunction isSameRouteLocationParamsValue(a, b) {\r\n    return Array.isArray(a)\r\n        ? isEquivalentArray(a, b)\r\n        : Array.isArray(b)\r\n            ? isEquivalentArray(b, a)\r\n            : a === b;\r\n}\r\n/**\r\n * Check if two arrays are the same or if an array with one single entry is the\r\n * same as another primitive value. Used to check query and parameters\r\n *\r\n * @param a - array of values\r\n * @param b - array of values or a single value\r\n */\r\nfunction isEquivalentArray(a, b) {\r\n    return Array.isArray(b)\r\n        ? a.length === b.length && a.every((value, i) => value === b[i])\r\n        : a.length === 1 && a[0] === b;\r\n}\r\n/**\r\n * Resolves a relative path that starts with `.`.\r\n *\r\n * @param to - path location we are resolving\r\n * @param from - currentLocation.path, should start with `/`\r\n */\r\nfunction resolveRelativePath(to, from) {\r\n    if (to.startsWith('/'))\r\n        return to;\r\n    if ((process.env.NODE_ENV !== 'production') && !from.startsWith('/')) {\r\n        warn(`Cannot resolve a relative location without an absolute path. Trying to resolve \"${to}\" from \"${from}\". It should look like \"/${from}\".`);\r\n        return to;\r\n    }\r\n    if (!to)\r\n        return from;\r\n    const fromSegments = from.split('/');\r\n    const toSegments = to.split('/');\r\n    let position = fromSegments.length - 1;\r\n    let toPosition;\r\n    let segment;\r\n    for (toPosition = 0; toPosition < toSegments.length; toPosition++) {\r\n        segment = toSegments[toPosition];\r\n        // can't go below zero\r\n        if (position === 1 || segment === '.')\r\n            continue;\r\n        if (segment === '..')\r\n            position--;\r\n        // found something that is not relative path\r\n        else\r\n            break;\r\n    }\r\n    return (fromSegments.slice(0, position).join('/') +\r\n        '/' +\r\n        toSegments\r\n            .slice(toPosition - (toPosition === toSegments.length ? 1 : 0))\r\n            .join('/'));\r\n}\n\nvar NavigationType;\r\n(function (NavigationType) {\r\n    NavigationType[\"pop\"] = \"pop\";\r\n    NavigationType[\"push\"] = \"push\";\r\n})(NavigationType || (NavigationType = {}));\r\nvar NavigationDirection;\r\n(function (NavigationDirection) {\r\n    NavigationDirection[\"back\"] = \"back\";\r\n    NavigationDirection[\"forward\"] = \"forward\";\r\n    NavigationDirection[\"unknown\"] = \"\";\r\n})(NavigationDirection || (NavigationDirection = {}));\r\n/**\r\n * Starting location for Histories\r\n */\r\nconst START = '';\r\n// Generic utils\r\n/**\r\n * Normalizes a base by removing any trailing slash and reading the base tag if\r\n * present.\r\n *\r\n * @param base - base to normalize\r\n */\r\nfunction normalizeBase(base) {\r\n    if (!base) {\r\n        if (isBrowser) {\r\n            // respect <base> tag\r\n            const baseEl = document.querySelector('base');\r\n            base = (baseEl && baseEl.getAttribute('href')) || '/';\r\n            // strip full URL origin\r\n            base = base.replace(/^\\w+:\\/\\/[^\\/]+/, '');\r\n        }\r\n        else {\r\n            base = '/';\r\n        }\r\n    }\r\n    // ensure leading slash when it was removed by the regex above avoid leading\r\n    // slash with hash because the file could be read from the disk like file://\r\n    // and the leading slash would cause problems\r\n    if (base[0] !== '/' && base[0] !== '#')\r\n        base = '/' + base;\r\n    // remove the trailing slash so all other method can just do `base + fullPath`\r\n    // to build an href\r\n    return removeTrailingSlash(base);\r\n}\r\n// remove any character before the hash\r\nconst BEFORE_HASH_RE = /^[^#]+#/;\r\nfunction createHref(base, location) {\r\n    return base.replace(BEFORE_HASH_RE, '#') + location;\r\n}\n\nfunction getElementPosition(el, offset) {\r\n    const docRect = document.documentElement.getBoundingClientRect();\r\n    const elRect = el.getBoundingClientRect();\r\n    return {\r\n        behavior: offset.behavior,\r\n        left: elRect.left - docRect.left - (offset.left || 0),\r\n        top: elRect.top - docRect.top - (offset.top || 0),\r\n    };\r\n}\r\nconst computeScrollPosition = () => ({\r\n    left: window.pageXOffset,\r\n    top: window.pageYOffset,\r\n});\r\nfunction scrollToPosition(position) {\r\n    let scrollToOptions;\r\n    if ('el' in position) {\r\n        const positionEl = position.el;\r\n        const isIdSelector = typeof positionEl === 'string' && positionEl.startsWith('#');\r\n        /**\r\n         * `id`s can accept pretty much any characters, including CSS combinators\r\n         * like `>` or `~`. It's still possible to retrieve elements using\r\n         * `document.getElementById('~')` but it needs to be escaped when using\r\n         * `document.querySelector('#\\\\~')` for it to be valid. The only\r\n         * requirements for `id`s are them to be unique on the page and to not be\r\n         * empty (`id=\"\"`). Because of that, when passing an id selector, it should\r\n         * be properly escaped for it to work with `querySelector`. We could check\r\n         * for the id selector to be simple (no CSS combinators `+ >~`) but that\r\n         * would make things inconsistent since they are valid characters for an\r\n         * `id` but would need to be escaped when using `querySelector`, breaking\r\n         * their usage and ending up in no selector returned. Selectors need to be\r\n         * escaped:\r\n         *\r\n         * - `#1-thing` becomes `#\\31 -thing`\r\n         * - `#with~symbols` becomes `#with\\\\~symbols`\r\n         *\r\n         * - More information about  the topic can be found at\r\n         *   https://mathiasbynens.be/notes/html5-id-class.\r\n         * - Practical example: https://mathiasbynens.be/demo/html5-id\r\n         */\r\n        if ((process.env.NODE_ENV !== 'production') && typeof position.el === 'string') {\r\n            if (!isIdSelector || !document.getElementById(position.el.slice(1))) {\r\n                try {\r\n                    const foundEl = document.querySelector(position.el);\r\n                    if (isIdSelector && foundEl) {\r\n                        warn(`The selector \"${position.el}\" should be passed as \"el: document.querySelector('${position.el}')\" because it starts with \"#\".`);\r\n                        // return to avoid other warnings\r\n                        return;\r\n                    }\r\n                }\r\n                catch (err) {\r\n                    warn(`The selector \"${position.el}\" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`);\r\n                    // return to avoid other warnings\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        const el = typeof positionEl === 'string'\r\n            ? isIdSelector\r\n                ? document.getElementById(positionEl.slice(1))\r\n                : document.querySelector(positionEl)\r\n            : positionEl;\r\n        if (!el) {\r\n            (process.env.NODE_ENV !== 'production') &&\r\n                warn(`Couldn't find element using selector \"${position.el}\" returned by scrollBehavior.`);\r\n            return;\r\n        }\r\n        scrollToOptions = getElementPosition(el, position);\r\n    }\r\n    else {\r\n        scrollToOptions = position;\r\n    }\r\n    if ('scrollBehavior' in document.documentElement.style)\r\n        window.scrollTo(scrollToOptions);\r\n    else {\r\n        window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);\r\n    }\r\n}\r\nfunction getScrollKey(path, delta) {\r\n    const position = history.state ? history.state.position - delta : -1;\r\n    return position + path;\r\n}\r\nconst scrollPositions = new Map();\r\nfunction saveScrollPosition(key, scrollPosition) {\r\n    scrollPositions.set(key, scrollPosition);\r\n}\r\nfunction getSavedScrollPosition(key) {\r\n    const scroll = scrollPositions.get(key);\r\n    // consume it so it's not used again\r\n    scrollPositions.delete(key);\r\n    return scroll;\r\n}\r\n// TODO: RFC about how to save scroll position\r\n/**\r\n * ScrollBehavior instance used by the router to compute and restore the scroll\r\n * position when navigating.\r\n */\r\n// export interface ScrollHandler<ScrollPositionEntry extends HistoryStateValue, ScrollPosition extends ScrollPositionEntry> {\r\n//   // returns a scroll position that can be saved in history\r\n//   compute(): ScrollPositionEntry\r\n//   // can take an extended ScrollPositionEntry\r\n//   scroll(position: ScrollPosition): void\r\n// }\r\n// export const scrollHandler: ScrollHandler<ScrollPosition> = {\r\n//   compute: computeScroll,\r\n//   scroll: scrollToPosition,\r\n// }\n\nlet createBaseLocation = () => location.protocol + '//' + location.host;\r\n/**\r\n * Creates a normalized history location from a window.location object\r\n * @param location -\r\n */\r\nfunction createCurrentLocation(base, location) {\r\n    const { pathname, search, hash } = location;\r\n    // allows hash bases like #, /#, #/, #!, #!/, /#!/, or even /folder#end\r\n    const hashPos = base.indexOf('#');\r\n    if (hashPos > -1) {\r\n        let slicePos = hash.includes(base.slice(hashPos))\r\n            ? base.slice(hashPos).length\r\n            : 1;\r\n        let pathFromHash = hash.slice(slicePos);\r\n        // prepend the starting slash to hash so the url starts with /#\r\n        if (pathFromHash[0] !== '/')\r\n            pathFromHash = '/' + pathFromHash;\r\n        return stripBase(pathFromHash, '');\r\n    }\r\n    const path = stripBase(pathname, base);\r\n    return path + search + hash;\r\n}\r\nfunction useHistoryListeners(base, historyState, currentLocation, replace) {\r\n    let listeners = [];\r\n    let teardowns = [];\r\n    // TODO: should it be a stack? a Dict. Check if the popstate listener\r\n    // can trigger twice\r\n    let pauseState = null;\r\n    const popStateHandler = ({ state, }) => {\r\n        const to = createCurrentLocation(base, location);\r\n        const from = currentLocation.value;\r\n        const fromState = historyState.value;\r\n        let delta = 0;\r\n        if (state) {\r\n            currentLocation.value = to;\r\n            historyState.value = state;\r\n            // ignore the popstate and reset the pauseState\r\n            if (pauseState && pauseState === from) {\r\n                pauseState = null;\r\n                return;\r\n            }\r\n            delta = fromState ? state.position - fromState.position : 0;\r\n        }\r\n        else {\r\n            replace(to);\r\n        }\r\n        // console.log({ deltaFromCurrent })\r\n        // Here we could also revert the navigation by calling history.go(-delta)\r\n        // this listener will have to be adapted to not trigger again and to wait for the url\r\n        // to be updated before triggering the listeners. Some kind of validation function would also\r\n        // need to be passed to the listeners so the navigation can be accepted\r\n        // call all listeners\r\n        listeners.forEach(listener => {\r\n            listener(currentLocation.value, from, {\r\n                delta,\r\n                type: NavigationType.pop,\r\n                direction: delta\r\n                    ? delta > 0\r\n                        ? NavigationDirection.forward\r\n                        : NavigationDirection.back\r\n                    : NavigationDirection.unknown,\r\n            });\r\n        });\r\n    };\r\n    function pauseListeners() {\r\n        pauseState = currentLocation.value;\r\n    }\r\n    function listen(callback) {\r\n        // setup the listener and prepare teardown callbacks\r\n        listeners.push(callback);\r\n        const teardown = () => {\r\n            const index = listeners.indexOf(callback);\r\n            if (index > -1)\r\n                listeners.splice(index, 1);\r\n        };\r\n        teardowns.push(teardown);\r\n        return teardown;\r\n    }\r\n    function beforeUnloadListener() {\r\n        const { history } = window;\r\n        if (!history.state)\r\n            return;\r\n        history.replaceState(assign({}, history.state, { scroll: computeScrollPosition() }), '');\r\n    }\r\n    function destroy() {\r\n        for (const teardown of teardowns)\r\n            teardown();\r\n        teardowns = [];\r\n        window.removeEventListener('popstate', popStateHandler);\r\n        window.removeEventListener('beforeunload', beforeUnloadListener);\r\n    }\r\n    // setup the listeners and prepare teardown callbacks\r\n    window.addEventListener('popstate', popStateHandler);\r\n    window.addEventListener('beforeunload', beforeUnloadListener);\r\n    return {\r\n        pauseListeners,\r\n        listen,\r\n        destroy,\r\n    };\r\n}\r\n/**\r\n * Creates a state object\r\n */\r\nfunction buildState(back, current, forward, replaced = false, computeScroll = false) {\r\n    return {\r\n        back,\r\n        current,\r\n        forward,\r\n        replaced,\r\n        position: window.history.length,\r\n        scroll: computeScroll ? computeScrollPosition() : null,\r\n    };\r\n}\r\nfunction useHistoryStateNavigation(base) {\r\n    const { history, location } = window;\r\n    // private variables\r\n    const currentLocation = {\r\n        value: createCurrentLocation(base, location),\r\n    };\r\n    const historyState = { value: history.state };\r\n    // build current history entry as this is a fresh navigation\r\n    if (!historyState.value) {\r\n        changeLocation(currentLocation.value, {\r\n            back: null,\r\n            current: currentLocation.value,\r\n            forward: null,\r\n            // the length is off by one, we need to decrease it\r\n            position: history.length - 1,\r\n            replaced: true,\r\n            // don't add a scroll as the user may have an anchor and we want\r\n            // scrollBehavior to be triggered without a saved position\r\n            scroll: null,\r\n        }, true);\r\n    }\r\n    function changeLocation(to, state, replace) {\r\n        /**\r\n         * if a base tag is provided and we are on a normal domain, we have to\r\n         * respect the provided `base` attribute because pushState() will use it and\r\n         * potentially erase anything before the `#` like at\r\n         * https://github.com/vuejs/router/issues/685 where a base of\r\n         * `/folder/#` but a base of `/` would erase the `/folder/` section. If\r\n         * there is no host, the `<base>` tag makes no sense and if there isn't a\r\n         * base tag we can just use everything after the `#`.\r\n         */\r\n        const hashIndex = base.indexOf('#');\r\n        const url = hashIndex > -1\r\n            ? (location.host && document.querySelector('base')\r\n                ? base\r\n                : base.slice(hashIndex)) + to\r\n            : createBaseLocation() + base + to;\r\n        try {\r\n            // BROWSER QUIRK\r\n            // NOTE: Safari throws a SecurityError when calling this function 100 times in 30 seconds\r\n            history[replace ? 'replaceState' : 'pushState'](state, '', url);\r\n            historyState.value = state;\r\n        }\r\n        catch (err) {\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                warn('Error with push/replace State', err);\r\n            }\r\n            else {\r\n                console.error(err);\r\n            }\r\n            // Force the navigation, this also resets the call count\r\n            location[replace ? 'replace' : 'assign'](url);\r\n        }\r\n    }\r\n    function replace(to, data) {\r\n        const state = assign({}, history.state, buildState(historyState.value.back, \r\n        // keep back and forward entries but override current position\r\n        to, historyState.value.forward, true), data, { position: historyState.value.position });\r\n        changeLocation(to, state, true);\r\n        currentLocation.value = to;\r\n    }\r\n    function push(to, data) {\r\n        // Add to current entry the information of where we are going\r\n        // as well as saving the current position\r\n        const currentState = assign({}, \r\n        // use current history state to gracefully handle a wrong call to\r\n        // history.replaceState\r\n        // https://github.com/vuejs/router/issues/366\r\n        historyState.value, history.state, {\r\n            forward: to,\r\n            scroll: computeScrollPosition(),\r\n        });\r\n        if ((process.env.NODE_ENV !== 'production') && !history.state) {\r\n            warn(`history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:\\n\\n` +\r\n                `history.replaceState(history.state, '', url)\\n\\n` +\r\n                `You can find more information at https://next.router.vuejs.org/guide/migration/#usage-of-history-state.`);\r\n        }\r\n        changeLocation(currentState.current, currentState, true);\r\n        const state = assign({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);\r\n        changeLocation(to, state, false);\r\n        currentLocation.value = to;\r\n    }\r\n    return {\r\n        location: currentLocation,\r\n        state: historyState,\r\n        push,\r\n        replace,\r\n    };\r\n}\r\n/**\r\n * Creates an HTML5 history. Most common history for single page applications.\r\n *\r\n * @param base -\r\n */\r\nfunction createWebHistory(base) {\r\n    base = normalizeBase(base);\r\n    const historyNavigation = useHistoryStateNavigation(base);\r\n    const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);\r\n    function go(delta, triggerListeners = true) {\r\n        if (!triggerListeners)\r\n            historyListeners.pauseListeners();\r\n        history.go(delta);\r\n    }\r\n    const routerHistory = assign({\r\n        // it's overridden right after\r\n        location: '',\r\n        base,\r\n        go,\r\n        createHref: createHref.bind(null, base),\r\n    }, historyNavigation, historyListeners);\r\n    Object.defineProperty(routerHistory, 'location', {\r\n        enumerable: true,\r\n        get: () => historyNavigation.location.value,\r\n    });\r\n    Object.defineProperty(routerHistory, 'state', {\r\n        enumerable: true,\r\n        get: () => historyNavigation.state.value,\r\n    });\r\n    return routerHistory;\r\n}\n\n/**\r\n * Creates a in-memory based history. The main purpose of this history is to handle SSR. It starts in a special location that is nowhere.\r\n * It's up to the user to replace that location with the starter location by either calling `router.push` or `router.replace`.\r\n *\r\n * @param base - Base applied to all urls, defaults to '/'\r\n * @returns a history object that can be passed to the router constructor\r\n */\r\nfunction createMemoryHistory(base = '') {\r\n    let listeners = [];\r\n    let queue = [START];\r\n    let position = 0;\r\n    base = normalizeBase(base);\r\n    function setLocation(location) {\r\n        position++;\r\n        if (position === queue.length) {\r\n            // we are at the end, we can simply append a new entry\r\n            queue.push(location);\r\n        }\r\n        else {\r\n            // we are in the middle, we remove everything from here in the queue\r\n            queue.splice(position);\r\n            queue.push(location);\r\n        }\r\n    }\r\n    function triggerListeners(to, from, { direction, delta }) {\r\n        const info = {\r\n            direction,\r\n            delta,\r\n            type: NavigationType.pop,\r\n        };\r\n        for (const callback of listeners) {\r\n            callback(to, from, info);\r\n        }\r\n    }\r\n    const routerHistory = {\r\n        // rewritten by Object.defineProperty\r\n        location: START,\r\n        // TODO: should be kept in queue\r\n        state: {},\r\n        base,\r\n        createHref: createHref.bind(null, base),\r\n        replace(to) {\r\n            // remove current entry and decrement position\r\n            queue.splice(position--, 1);\r\n            setLocation(to);\r\n        },\r\n        push(to, data) {\r\n            setLocation(to);\r\n        },\r\n        listen(callback) {\r\n            listeners.push(callback);\r\n            return () => {\r\n                const index = listeners.indexOf(callback);\r\n                if (index > -1)\r\n                    listeners.splice(index, 1);\r\n            };\r\n        },\r\n        destroy() {\r\n            listeners = [];\r\n            queue = [START];\r\n            position = 0;\r\n        },\r\n        go(delta, shouldTrigger = true) {\r\n            const from = this.location;\r\n            const direction = \r\n            // we are considering delta === 0 going forward, but in abstract mode\r\n            // using 0 for the delta doesn't make sense like it does in html5 where\r\n            // it reloads the page\r\n            delta < 0 ? NavigationDirection.back : NavigationDirection.forward;\r\n            position = Math.max(0, Math.min(position + delta, queue.length - 1));\r\n            if (shouldTrigger) {\r\n                triggerListeners(this.location, from, {\r\n                    direction,\r\n                    delta,\r\n                });\r\n            }\r\n        },\r\n    };\r\n    Object.defineProperty(routerHistory, 'location', {\r\n        enumerable: true,\r\n        get: () => queue[position],\r\n    });\r\n    return routerHistory;\r\n}\n\n/**\r\n * Creates a hash history. Useful for web applications with no host (e.g.\r\n * `file://`) or when configuring a server to handle any URL is not possible.\r\n *\r\n * @param base - optional base to provide. Defaults to `location.pathname +\r\n * location.search` If there is a `<base>` tag in the `head`, its value will be\r\n * ignored in favor of this parameter **but note it affects all the\r\n * history.pushState() calls**, meaning that if you use a `<base>` tag, it's\r\n * `href` value **has to match this parameter** (ignoring anything after the\r\n * `#`).\r\n *\r\n * @example\r\n * ```js\r\n * // at https://example.com/folder\r\n * createWebHashHistory() // gives a url of `https://example.com/folder#`\r\n * createWebHashHistory('/folder/') // gives a url of `https://example.com/folder/#`\r\n * // if the `#` is provided in the base, it won't be added by `createWebHashHistory`\r\n * createWebHashHistory('/folder/#/app/') // gives a url of `https://example.com/folder/#/app/`\r\n * // you should avoid doing this because it changes the original url and breaks copying urls\r\n * createWebHashHistory('/other-folder/') // gives a url of `https://example.com/other-folder/#`\r\n *\r\n * // at file:///usr/etc/folder/index.html\r\n * // for locations with no `host`, the base is ignored\r\n * createWebHashHistory('/iAmIgnored') // gives a url of `file:///usr/etc/folder/index.html#`\r\n * ```\r\n */\r\nfunction createWebHashHistory(base) {\r\n    // Make sure this implementation is fine in terms of encoding, specially for IE11\r\n    // for `file://`, directly use the pathname and ignore the base\r\n    // location.pathname contains an initial `/` even at the root: `https://example.com`\r\n    base = location.host ? base || location.pathname + location.search : '';\r\n    // allow the user to provide a `#` in the middle: `/base/#/app`\r\n    if (!base.includes('#'))\r\n        base += '#';\r\n    if ((process.env.NODE_ENV !== 'production') && !base.endsWith('#/') && !base.endsWith('#')) {\r\n        warn(`A hash base must end with a \"#\":\\n\"${base}\" should be \"${base.replace(/#.*$/, '#')}\".`);\r\n    }\r\n    return createWebHistory(base);\r\n}\n\nfunction isRouteLocation(route) {\r\n    return typeof route === 'string' || (route && typeof route === 'object');\r\n}\r\nfunction isRouteName(name) {\r\n    return typeof name === 'string' || typeof name === 'symbol';\r\n}\n\n/**\r\n * Initial route location where the router is. Can be used in navigation guards\r\n * to differentiate the initial navigation.\r\n *\r\n * @example\r\n * ```js\r\n * import { START_LOCATION } from 'vue-router'\r\n *\r\n * router.beforeEach((to, from) => {\r\n *   if (from === START_LOCATION) {\r\n *     // initial navigation\r\n *   }\r\n * })\r\n * ```\r\n */\r\nconst START_LOCATION_NORMALIZED = {\r\n    path: '/',\r\n    name: undefined,\r\n    params: {},\r\n    query: {},\r\n    hash: '',\r\n    fullPath: '/',\r\n    matched: [],\r\n    meta: {},\r\n    redirectedFrom: undefined,\r\n};\n\nconst NavigationFailureSymbol = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'navigation failure' : 'nf');\r\n/**\r\n * Enumeration with all possible types for navigation failures. Can be passed to\r\n * {@link isNavigationFailure} to check for specific failures.\r\n */\r\nvar NavigationFailureType;\r\n(function (NavigationFailureType) {\r\n    /**\r\n     * An aborted navigation is a navigation that failed because a navigation\r\n     * guard returned `false` or called `next(false)`\r\n     */\r\n    NavigationFailureType[NavigationFailureType[\"aborted\"] = 4] = \"aborted\";\r\n    /**\r\n     * A cancelled navigation is a navigation that failed because a more recent\r\n     * navigation finished started (not necessarily finished).\r\n     */\r\n    NavigationFailureType[NavigationFailureType[\"cancelled\"] = 8] = \"cancelled\";\r\n    /**\r\n     * A duplicated navigation is a navigation that failed because it was\r\n     * initiated while already being at the exact same location.\r\n     */\r\n    NavigationFailureType[NavigationFailureType[\"duplicated\"] = 16] = \"duplicated\";\r\n})(NavigationFailureType || (NavigationFailureType = {}));\r\n// DEV only debug messages\r\nconst ErrorTypeMessages = {\r\n    [1 /* MATCHER_NOT_FOUND */]({ location, currentLocation }) {\r\n        return `No match for\\n ${JSON.stringify(location)}${currentLocation\r\n            ? '\\nwhile being at\\n' + JSON.stringify(currentLocation)\r\n            : ''}`;\r\n    },\r\n    [2 /* NAVIGATION_GUARD_REDIRECT */]({ from, to, }) {\r\n        return `Redirected from \"${from.fullPath}\" to \"${stringifyRoute(to)}\" via a navigation guard.`;\r\n    },\r\n    [4 /* NAVIGATION_ABORTED */]({ from, to }) {\r\n        return `Navigation aborted from \"${from.fullPath}\" to \"${to.fullPath}\" via a navigation guard.`;\r\n    },\r\n    [8 /* NAVIGATION_CANCELLED */]({ from, to }) {\r\n        return `Navigation cancelled from \"${from.fullPath}\" to \"${to.fullPath}\" with a new navigation.`;\r\n    },\r\n    [16 /* NAVIGATION_DUPLICATED */]({ from, to }) {\r\n        return `Avoided redundant navigation to current location: \"${from.fullPath}\".`;\r\n    },\r\n};\r\nfunction createRouterError(type, params) {\r\n    // keep full error messages in cjs versions\r\n    if ((process.env.NODE_ENV !== 'production') || !true) {\r\n        return assign(new Error(ErrorTypeMessages[type](params)), {\r\n            type,\r\n            [NavigationFailureSymbol]: true,\r\n        }, params);\r\n    }\r\n    else {\r\n        return assign(new Error(), {\r\n            type,\r\n            [NavigationFailureSymbol]: true,\r\n        }, params);\r\n    }\r\n}\r\nfunction isNavigationFailure(error, type) {\r\n    return (error instanceof Error &&\r\n        NavigationFailureSymbol in error &&\r\n        (type == null || !!(error.type & type)));\r\n}\r\nconst propertiesToLog = ['params', 'query', 'hash'];\r\nfunction stringifyRoute(to) {\r\n    if (typeof to === 'string')\r\n        return to;\r\n    if ('path' in to)\r\n        return to.path;\r\n    const location = {};\r\n    for (const key of propertiesToLog) {\r\n        if (key in to)\r\n            location[key] = to[key];\r\n    }\r\n    return JSON.stringify(location, null, 2);\r\n}\n\n// default pattern for a param: non greedy everything but /\r\nconst BASE_PARAM_PATTERN = '[^/]+?';\r\nconst BASE_PATH_PARSER_OPTIONS = {\r\n    sensitive: false,\r\n    strict: false,\r\n    start: true,\r\n    end: true,\r\n};\r\n// Special Regex characters that must be escaped in static tokens\r\nconst REGEX_CHARS_RE = /[.+*?^${}()[\\]/\\\\]/g;\r\n/**\r\n * Creates a path parser from an array of Segments (a segment is an array of Tokens)\r\n *\r\n * @param segments - array of segments returned by tokenizePath\r\n * @param extraOptions - optional options for the regexp\r\n * @returns a PathParser\r\n */\r\nfunction tokensToParser(segments, extraOptions) {\r\n    const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);\r\n    // the amount of scores is the same as the length of segments except for the root segment \"/\"\r\n    const score = [];\r\n    // the regexp as a string\r\n    let pattern = options.start ? '^' : '';\r\n    // extracted keys\r\n    const keys = [];\r\n    for (const segment of segments) {\r\n        // the root segment needs special treatment\r\n        const segmentScores = segment.length ? [] : [90 /* Root */];\r\n        // allow trailing slash\r\n        if (options.strict && !segment.length)\r\n            pattern += '/';\r\n        for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {\r\n            const token = segment[tokenIndex];\r\n            // resets the score if we are inside a sub segment /:a-other-:b\r\n            let subSegmentScore = 40 /* Segment */ +\r\n                (options.sensitive ? 0.25 /* BonusCaseSensitive */ : 0);\r\n            if (token.type === 0 /* Static */) {\r\n                // prepend the slash if we are starting a new segment\r\n                if (!tokenIndex)\r\n                    pattern += '/';\r\n                pattern += token.value.replace(REGEX_CHARS_RE, '\\\\$&');\r\n                subSegmentScore += 40 /* Static */;\r\n            }\r\n            else if (token.type === 1 /* Param */) {\r\n                const { value, repeatable, optional, regexp } = token;\r\n                keys.push({\r\n                    name: value,\r\n                    repeatable,\r\n                    optional,\r\n                });\r\n                const re = regexp ? regexp : BASE_PARAM_PATTERN;\r\n                // the user provided a custom regexp /:id(\\\\d+)\r\n                if (re !== BASE_PARAM_PATTERN) {\r\n                    subSegmentScore += 10 /* BonusCustomRegExp */;\r\n                    // make sure the regexp is valid before using it\r\n                    try {\r\n                        new RegExp(`(${re})`);\r\n                    }\r\n                    catch (err) {\r\n                        throw new Error(`Invalid custom RegExp for param \"${value}\" (${re}): ` +\r\n                            err.message);\r\n                    }\r\n                }\r\n                // when we repeat we must take care of the repeating leading slash\r\n                let subPattern = repeatable ? `((?:${re})(?:/(?:${re}))*)` : `(${re})`;\r\n                // prepend the slash if we are starting a new segment\r\n                if (!tokenIndex)\r\n                    subPattern =\r\n                        // avoid an optional / if there are more segments e.g. /:p?-static\r\n                        // or /:p?-:p2\r\n                        optional && segment.length < 2\r\n                            ? `(?:/${subPattern})`\r\n                            : '/' + subPattern;\r\n                if (optional)\r\n                    subPattern += '?';\r\n                pattern += subPattern;\r\n                subSegmentScore += 20 /* Dynamic */;\r\n                if (optional)\r\n                    subSegmentScore += -8 /* BonusOptional */;\r\n                if (repeatable)\r\n                    subSegmentScore += -20 /* BonusRepeatable */;\r\n                if (re === '.*')\r\n                    subSegmentScore += -50 /* BonusWildcard */;\r\n            }\r\n            segmentScores.push(subSegmentScore);\r\n        }\r\n        // an empty array like /home/ -> [[{home}], []]\r\n        // if (!segment.length) pattern += '/'\r\n        score.push(segmentScores);\r\n    }\r\n    // only apply the strict bonus to the last score\r\n    if (options.strict && options.end) {\r\n        const i = score.length - 1;\r\n        score[i][score[i].length - 1] += 0.7000000000000001 /* BonusStrict */;\r\n    }\r\n    // TODO: dev only warn double trailing slash\r\n    if (!options.strict)\r\n        pattern += '/?';\r\n    if (options.end)\r\n        pattern += '$';\r\n    // allow paths like /dynamic to only match dynamic or dynamic/... but not dynamic_something_else\r\n    else if (options.strict)\r\n        pattern += '(?:/|$)';\r\n    const re = new RegExp(pattern, options.sensitive ? '' : 'i');\r\n    function parse(path) {\r\n        const match = path.match(re);\r\n        const params = {};\r\n        if (!match)\r\n            return null;\r\n        for (let i = 1; i < match.length; i++) {\r\n            const value = match[i] || '';\r\n            const key = keys[i - 1];\r\n            params[key.name] = value && key.repeatable ? value.split('/') : value;\r\n        }\r\n        return params;\r\n    }\r\n    function stringify(params) {\r\n        let path = '';\r\n        // for optional parameters to allow to be empty\r\n        let avoidDuplicatedSlash = false;\r\n        for (const segment of segments) {\r\n            if (!avoidDuplicatedSlash || !path.endsWith('/'))\r\n                path += '/';\r\n            avoidDuplicatedSlash = false;\r\n            for (const token of segment) {\r\n                if (token.type === 0 /* Static */) {\r\n                    path += token.value;\r\n                }\r\n                else if (token.type === 1 /* Param */) {\r\n                    const { value, repeatable, optional } = token;\r\n                    const param = value in params ? params[value] : '';\r\n                    if (Array.isArray(param) && !repeatable)\r\n                        throw new Error(`Provided param \"${value}\" is an array but it is not repeatable (* or + modifiers)`);\r\n                    const text = Array.isArray(param) ? param.join('/') : param;\r\n                    if (!text) {\r\n                        if (optional) {\r\n                            // if we have more than one optional param like /:a?-static we\r\n                            // don't need to care about the optional param\r\n                            if (segment.length < 2) {\r\n                                // remove the last slash as we could be at the end\r\n                                if (path.endsWith('/'))\r\n                                    path = path.slice(0, -1);\r\n                                // do not append a slash on the next iteration\r\n                                else\r\n                                    avoidDuplicatedSlash = true;\r\n                            }\r\n                        }\r\n                        else\r\n                            throw new Error(`Missing required param \"${value}\"`);\r\n                    }\r\n                    path += text;\r\n                }\r\n            }\r\n        }\r\n        return path;\r\n    }\r\n    return {\r\n        re,\r\n        score,\r\n        keys,\r\n        parse,\r\n        stringify,\r\n    };\r\n}\r\n/**\r\n * Compares an array of numbers as used in PathParser.score and returns a\r\n * number. This function can be used to `sort` an array\r\n *\r\n * @param a - first array of numbers\r\n * @param b - second array of numbers\r\n * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\r\n * should be sorted first\r\n */\r\nfunction compareScoreArray(a, b) {\r\n    let i = 0;\r\n    while (i < a.length && i < b.length) {\r\n        const diff = b[i] - a[i];\r\n        // only keep going if diff === 0\r\n        if (diff)\r\n            return diff;\r\n        i++;\r\n    }\r\n    // if the last subsegment was Static, the shorter segments should be sorted first\r\n    // otherwise sort the longest segment first\r\n    if (a.length < b.length) {\r\n        return a.length === 1 && a[0] === 40 /* Static */ + 40 /* Segment */\r\n            ? -1\r\n            : 1;\r\n    }\r\n    else if (a.length > b.length) {\r\n        return b.length === 1 && b[0] === 40 /* Static */ + 40 /* Segment */\r\n            ? 1\r\n            : -1;\r\n    }\r\n    return 0;\r\n}\r\n/**\r\n * Compare function that can be used with `sort` to sort an array of PathParser\r\n *\r\n * @param a - first PathParser\r\n * @param b - second PathParser\r\n * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\r\n */\r\nfunction comparePathParserScore(a, b) {\r\n    let i = 0;\r\n    const aScore = a.score;\r\n    const bScore = b.score;\r\n    while (i < aScore.length && i < bScore.length) {\r\n        const comp = compareScoreArray(aScore[i], bScore[i]);\r\n        // do not return if both are equal\r\n        if (comp)\r\n            return comp;\r\n        i++;\r\n    }\r\n    // if a and b share the same score entries but b has more, sort b first\r\n    return bScore.length - aScore.length;\r\n    // this is the ternary version\r\n    // return aScore.length < bScore.length\r\n    //   ? 1\r\n    //   : aScore.length > bScore.length\r\n    //   ? -1\r\n    //   : 0\r\n}\n\nconst ROOT_TOKEN = {\r\n    type: 0 /* Static */,\r\n    value: '',\r\n};\r\nconst VALID_PARAM_RE = /[a-zA-Z0-9_]/;\r\n// After some profiling, the cache seems to be unnecessary because tokenizePath\r\n// (the slowest part of adding a route) is very fast\r\n// const tokenCache = new Map<string, Token[][]>()\r\nfunction tokenizePath(path) {\r\n    if (!path)\r\n        return [[]];\r\n    if (path === '/')\r\n        return [[ROOT_TOKEN]];\r\n    if (!path.startsWith('/')) {\r\n        throw new Error((process.env.NODE_ENV !== 'production')\r\n            ? `Route paths should start with a \"/\": \"${path}\" should be \"/${path}\".`\r\n            : `Invalid path \"${path}\"`);\r\n    }\r\n    // if (tokenCache.has(path)) return tokenCache.get(path)!\r\n    function crash(message) {\r\n        throw new Error(`ERR (${state})/\"${buffer}\": ${message}`);\r\n    }\r\n    let state = 0 /* Static */;\r\n    let previousState = state;\r\n    const tokens = [];\r\n    // the segment will always be valid because we get into the initial state\r\n    // with the leading /\r\n    let segment;\r\n    function finalizeSegment() {\r\n        if (segment)\r\n            tokens.push(segment);\r\n        segment = [];\r\n    }\r\n    // index on the path\r\n    let i = 0;\r\n    // char at index\r\n    let char;\r\n    // buffer of the value read\r\n    let buffer = '';\r\n    // custom regexp for a param\r\n    let customRe = '';\r\n    function consumeBuffer() {\r\n        if (!buffer)\r\n            return;\r\n        if (state === 0 /* Static */) {\r\n            segment.push({\r\n                type: 0 /* Static */,\r\n                value: buffer,\r\n            });\r\n        }\r\n        else if (state === 1 /* Param */ ||\r\n            state === 2 /* ParamRegExp */ ||\r\n            state === 3 /* ParamRegExpEnd */) {\r\n            if (segment.length > 1 && (char === '*' || char === '+'))\r\n                crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);\r\n            segment.push({\r\n                type: 1 /* Param */,\r\n                value: buffer,\r\n                regexp: customRe,\r\n                repeatable: char === '*' || char === '+',\r\n                optional: char === '*' || char === '?',\r\n            });\r\n        }\r\n        else {\r\n            crash('Invalid state to consume buffer');\r\n        }\r\n        buffer = '';\r\n    }\r\n    function addCharToBuffer() {\r\n        buffer += char;\r\n    }\r\n    while (i < path.length) {\r\n        char = path[i++];\r\n        if (char === '\\\\' && state !== 2 /* ParamRegExp */) {\r\n            previousState = state;\r\n            state = 4 /* EscapeNext */;\r\n            continue;\r\n        }\r\n        switch (state) {\r\n            case 0 /* Static */:\r\n                if (char === '/') {\r\n                    if (buffer) {\r\n                        consumeBuffer();\r\n                    }\r\n                    finalizeSegment();\r\n                }\r\n                else if (char === ':') {\r\n                    consumeBuffer();\r\n                    state = 1 /* Param */;\r\n                }\r\n                else {\r\n                    addCharToBuffer();\r\n                }\r\n                break;\r\n            case 4 /* EscapeNext */:\r\n                addCharToBuffer();\r\n                state = previousState;\r\n                break;\r\n            case 1 /* Param */:\r\n                if (char === '(') {\r\n                    state = 2 /* ParamRegExp */;\r\n                }\r\n                else if (VALID_PARAM_RE.test(char)) {\r\n                    addCharToBuffer();\r\n                }\r\n                else {\r\n                    consumeBuffer();\r\n                    state = 0 /* Static */;\r\n                    // go back one character if we were not modifying\r\n                    if (char !== '*' && char !== '?' && char !== '+')\r\n                        i--;\r\n                }\r\n                break;\r\n            case 2 /* ParamRegExp */:\r\n                // TODO: is it worth handling nested regexp? like :p(?:prefix_([^/]+)_suffix)\r\n                // it already works by escaping the closing )\r\n                // https://paths.esm.dev/?p=AAMeJbiAwQEcDKbAoAAkP60PG2R6QAvgNaA6AFACM2ABuQBB#\r\n                // is this really something people need since you can also write\r\n                // /prefix_:p()_suffix\r\n                if (char === ')') {\r\n                    // handle the escaped )\r\n                    if (customRe[customRe.length - 1] == '\\\\')\r\n                        customRe = customRe.slice(0, -1) + char;\r\n                    else\r\n                        state = 3 /* ParamRegExpEnd */;\r\n                }\r\n                else {\r\n                    customRe += char;\r\n                }\r\n                break;\r\n            case 3 /* ParamRegExpEnd */:\r\n                // same as finalizing a param\r\n                consumeBuffer();\r\n                state = 0 /* Static */;\r\n                // go back one character if we were not modifying\r\n                if (char !== '*' && char !== '?' && char !== '+')\r\n                    i--;\r\n                customRe = '';\r\n                break;\r\n            default:\r\n                crash('Unknown state');\r\n                break;\r\n        }\r\n    }\r\n    if (state === 2 /* ParamRegExp */)\r\n        crash(`Unfinished custom RegExp for param \"${buffer}\"`);\r\n    consumeBuffer();\r\n    finalizeSegment();\r\n    // tokenCache.set(path, tokens)\r\n    return tokens;\r\n}\n\nfunction createRouteRecordMatcher(record, parent, options) {\r\n    const parser = tokensToParser(tokenizePath(record.path), options);\r\n    // warn against params with the same name\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        const existingKeys = new Set();\r\n        for (const key of parser.keys) {\r\n            if (existingKeys.has(key.name))\r\n                warn(`Found duplicated params with name \"${key.name}\" for path \"${record.path}\". Only the last one will be available on \"$route.params\".`);\r\n            existingKeys.add(key.name);\r\n        }\r\n    }\r\n    const matcher = assign(parser, {\r\n        record,\r\n        parent,\r\n        // these needs to be populated by the parent\r\n        children: [],\r\n        alias: [],\r\n    });\r\n    if (parent) {\r\n        // both are aliases or both are not aliases\r\n        // we don't want to mix them because the order is used when\r\n        // passing originalRecord in Matcher.addRoute\r\n        if (!matcher.record.aliasOf === !parent.record.aliasOf)\r\n            parent.children.push(matcher);\r\n    }\r\n    return matcher;\r\n}\n\n/**\r\n * Creates a Router Matcher.\r\n *\r\n * @internal\r\n * @param routes - array of initial routes\r\n * @param globalOptions - global route options\r\n */\r\nfunction createRouterMatcher(routes, globalOptions) {\r\n    // normalized ordered array of matchers\r\n    const matchers = [];\r\n    const matcherMap = new Map();\r\n    globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);\r\n    function getRecordMatcher(name) {\r\n        return matcherMap.get(name);\r\n    }\r\n    function addRoute(record, parent, originalRecord) {\r\n        // used later on to remove by name\r\n        const isRootAdd = !originalRecord;\r\n        const mainNormalizedRecord = normalizeRouteRecord(record);\r\n        // we might be the child of an alias\r\n        mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;\r\n        const options = mergeOptions(globalOptions, record);\r\n        // generate an array of records to correctly handle aliases\r\n        const normalizedRecords = [\r\n            mainNormalizedRecord,\r\n        ];\r\n        if ('alias' in record) {\r\n            const aliases = typeof record.alias === 'string' ? [record.alias] : record.alias;\r\n            for (const alias of aliases) {\r\n                normalizedRecords.push(assign({}, mainNormalizedRecord, {\r\n                    // this allows us to hold a copy of the `components` option\r\n                    // so that async components cache is hold on the original record\r\n                    components: originalRecord\r\n                        ? originalRecord.record.components\r\n                        : mainNormalizedRecord.components,\r\n                    path: alias,\r\n                    // we might be the child of an alias\r\n                    aliasOf: originalRecord\r\n                        ? originalRecord.record\r\n                        : mainNormalizedRecord,\r\n                    // the aliases are always of the same kind as the original since they\r\n                    // are defined on the same record\r\n                }));\r\n            }\r\n        }\r\n        let matcher;\r\n        let originalMatcher;\r\n        for (const normalizedRecord of normalizedRecords) {\r\n            const { path } = normalizedRecord;\r\n            // Build up the path for nested routes if the child isn't an absolute\r\n            // route. Only add the / delimiter if the child path isn't empty and if the\r\n            // parent path doesn't have a trailing slash\r\n            if (parent && path[0] !== '/') {\r\n                const parentPath = parent.record.path;\r\n                const connectingSlash = parentPath[parentPath.length - 1] === '/' ? '' : '/';\r\n                normalizedRecord.path =\r\n                    parent.record.path + (path && connectingSlash + path);\r\n            }\r\n            if ((process.env.NODE_ENV !== 'production') && normalizedRecord.path === '*') {\r\n                throw new Error('Catch all routes (\"*\") must now be defined using a param with a custom regexp.\\n' +\r\n                    'See more at https://next.router.vuejs.org/guide/migration/#removed-star-or-catch-all-routes.');\r\n            }\r\n            // create the object before hand so it can be passed to children\r\n            matcher = createRouteRecordMatcher(normalizedRecord, parent, options);\r\n            if ((process.env.NODE_ENV !== 'production') && parent && path[0] === '/')\r\n                checkMissingParamsInAbsolutePath(matcher, parent);\r\n            // if we are an alias we must tell the original record that we exist\r\n            // so we can be removed\r\n            if (originalRecord) {\r\n                originalRecord.alias.push(matcher);\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    checkSameParams(originalRecord, matcher);\r\n                }\r\n            }\r\n            else {\r\n                // otherwise, the first record is the original and others are aliases\r\n                originalMatcher = originalMatcher || matcher;\r\n                if (originalMatcher !== matcher)\r\n                    originalMatcher.alias.push(matcher);\r\n                // remove the route if named and only for the top record (avoid in nested calls)\r\n                // this works because the original record is the first one\r\n                if (isRootAdd && record.name && !isAliasRecord(matcher))\r\n                    removeRoute(record.name);\r\n            }\r\n            if ('children' in mainNormalizedRecord) {\r\n                const children = mainNormalizedRecord.children;\r\n                for (let i = 0; i < children.length; i++) {\r\n                    addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);\r\n                }\r\n            }\r\n            // if there was no original record, then the first one was not an alias and all\r\n            // other alias (if any) need to reference this record when adding children\r\n            originalRecord = originalRecord || matcher;\r\n            // TODO: add normalized records for more flexibility\r\n            // if (parent && isAliasRecord(originalRecord)) {\r\n            //   parent.children.push(originalRecord)\r\n            // }\r\n            insertMatcher(matcher);\r\n        }\r\n        return originalMatcher\r\n            ? () => {\r\n                // since other matchers are aliases, they should be removed by the original matcher\r\n                removeRoute(originalMatcher);\r\n            }\r\n            : noop;\r\n    }\r\n    function removeRoute(matcherRef) {\r\n        if (isRouteName(matcherRef)) {\r\n            const matcher = matcherMap.get(matcherRef);\r\n            if (matcher) {\r\n                matcherMap.delete(matcherRef);\r\n                matchers.splice(matchers.indexOf(matcher), 1);\r\n                matcher.children.forEach(removeRoute);\r\n                matcher.alias.forEach(removeRoute);\r\n            }\r\n        }\r\n        else {\r\n            const index = matchers.indexOf(matcherRef);\r\n            if (index > -1) {\r\n                matchers.splice(index, 1);\r\n                if (matcherRef.record.name)\r\n                    matcherMap.delete(matcherRef.record.name);\r\n                matcherRef.children.forEach(removeRoute);\r\n                matcherRef.alias.forEach(removeRoute);\r\n            }\r\n        }\r\n    }\r\n    function getRoutes() {\r\n        return matchers;\r\n    }\r\n    function insertMatcher(matcher) {\r\n        let i = 0;\r\n        while (i < matchers.length &&\r\n            comparePathParserScore(matcher, matchers[i]) >= 0 &&\r\n            // Adding children with empty path should still appear before the parent\r\n            // https://github.com/vuejs/router/issues/1124\r\n            (matcher.record.path !== matchers[i].record.path ||\r\n                !isRecordChildOf(matcher, matchers[i])))\r\n            i++;\r\n        matchers.splice(i, 0, matcher);\r\n        // only add the original record to the name map\r\n        if (matcher.record.name && !isAliasRecord(matcher))\r\n            matcherMap.set(matcher.record.name, matcher);\r\n    }\r\n    function resolve(location, currentLocation) {\r\n        let matcher;\r\n        let params = {};\r\n        let path;\r\n        let name;\r\n        if ('name' in location && location.name) {\r\n            matcher = matcherMap.get(location.name);\r\n            if (!matcher)\r\n                throw createRouterError(1 /* MATCHER_NOT_FOUND */, {\r\n                    location,\r\n                });\r\n            name = matcher.record.name;\r\n            params = assign(\r\n            // paramsFromLocation is a new object\r\n            paramsFromLocation(currentLocation.params, \r\n            // only keep params that exist in the resolved location\r\n            // TODO: only keep optional params coming from a parent record\r\n            matcher.keys.filter(k => !k.optional).map(k => k.name)), location.params);\r\n            // throws if cannot be stringified\r\n            path = matcher.stringify(params);\r\n        }\r\n        else if ('path' in location) {\r\n            // no need to resolve the path with the matcher as it was provided\r\n            // this also allows the user to control the encoding\r\n            path = location.path;\r\n            if ((process.env.NODE_ENV !== 'production') && !path.startsWith('/')) {\r\n                warn(`The Matcher cannot resolve relative paths but received \"${path}\". Unless you directly called \\`matcher.resolve(\"${path}\")\\`, this is probably a bug in vue-router. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/router.`);\r\n            }\r\n            matcher = matchers.find(m => m.re.test(path));\r\n            // matcher should have a value after the loop\r\n            if (matcher) {\r\n                // TODO: dev warning of unused params if provided\r\n                // we know the matcher works because we tested the regexp\r\n                params = matcher.parse(path);\r\n                name = matcher.record.name;\r\n            }\r\n            // location is a relative path\r\n        }\r\n        else {\r\n            // match by name or path of current route\r\n            matcher = currentLocation.name\r\n                ? matcherMap.get(currentLocation.name)\r\n                : matchers.find(m => m.re.test(currentLocation.path));\r\n            if (!matcher)\r\n                throw createRouterError(1 /* MATCHER_NOT_FOUND */, {\r\n                    location,\r\n                    currentLocation,\r\n                });\r\n            name = matcher.record.name;\r\n            // since we are navigating to the same location, we don't need to pick the\r\n            // params like when `name` is provided\r\n            params = assign({}, currentLocation.params, location.params);\r\n            path = matcher.stringify(params);\r\n        }\r\n        const matched = [];\r\n        let parentMatcher = matcher;\r\n        while (parentMatcher) {\r\n            // reversed order so parents are at the beginning\r\n            matched.unshift(parentMatcher.record);\r\n            parentMatcher = parentMatcher.parent;\r\n        }\r\n        return {\r\n            name,\r\n            path,\r\n            params,\r\n            matched,\r\n            meta: mergeMetaFields(matched),\r\n        };\r\n    }\r\n    // add initial routes\r\n    routes.forEach(route => addRoute(route));\r\n    return { addRoute, resolve, removeRoute, getRoutes, getRecordMatcher };\r\n}\r\nfunction paramsFromLocation(params, keys) {\r\n    const newParams = {};\r\n    for (const key of keys) {\r\n        if (key in params)\r\n            newParams[key] = params[key];\r\n    }\r\n    return newParams;\r\n}\r\n/**\r\n * Normalizes a RouteRecordRaw. Creates a copy\r\n *\r\n * @param record\r\n * @returns the normalized version\r\n */\r\nfunction normalizeRouteRecord(record) {\r\n    return {\r\n        path: record.path,\r\n        redirect: record.redirect,\r\n        name: record.name,\r\n        meta: record.meta || {},\r\n        aliasOf: undefined,\r\n        beforeEnter: record.beforeEnter,\r\n        props: normalizeRecordProps(record),\r\n        children: record.children || [],\r\n        instances: {},\r\n        leaveGuards: new Set(),\r\n        updateGuards: new Set(),\r\n        enterCallbacks: {},\r\n        components: 'components' in record\r\n            ? record.components || {}\r\n            : { default: record.component },\r\n    };\r\n}\r\n/**\r\n * Normalize the optional `props` in a record to always be an object similar to\r\n * components. Also accept a boolean for components.\r\n * @param record\r\n */\r\nfunction normalizeRecordProps(record) {\r\n    const propsObject = {};\r\n    // props does not exist on redirect records but we can set false directly\r\n    const props = record.props || false;\r\n    if ('component' in record) {\r\n        propsObject.default = props;\r\n    }\r\n    else {\r\n        // NOTE: we could also allow a function to be applied to every component.\r\n        // Would need user feedback for use cases\r\n        for (const name in record.components)\r\n            propsObject[name] = typeof props === 'boolean' ? props : props[name];\r\n    }\r\n    return propsObject;\r\n}\r\n/**\r\n * Checks if a record or any of its parent is an alias\r\n * @param record\r\n */\r\nfunction isAliasRecord(record) {\r\n    while (record) {\r\n        if (record.record.aliasOf)\r\n            return true;\r\n        record = record.parent;\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Merge meta fields of an array of records\r\n *\r\n * @param matched - array of matched records\r\n */\r\nfunction mergeMetaFields(matched) {\r\n    return matched.reduce((meta, record) => assign(meta, record.meta), {});\r\n}\r\nfunction mergeOptions(defaults, partialOptions) {\r\n    const options = {};\r\n    for (const key in defaults) {\r\n        options[key] = key in partialOptions ? partialOptions[key] : defaults[key];\r\n    }\r\n    return options;\r\n}\r\nfunction isSameParam(a, b) {\r\n    return (a.name === b.name &&\r\n        a.optional === b.optional &&\r\n        a.repeatable === b.repeatable);\r\n}\r\n/**\r\n * Check if a path and its alias have the same required params\r\n *\r\n * @param a - original record\r\n * @param b - alias record\r\n */\r\nfunction checkSameParams(a, b) {\r\n    for (const key of a.keys) {\r\n        if (!key.optional && !b.keys.find(isSameParam.bind(null, key)))\r\n            return warn(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" should have the exact same param named \"${key.name}\"`);\r\n    }\r\n    for (const key of b.keys) {\r\n        if (!key.optional && !a.keys.find(isSameParam.bind(null, key)))\r\n            return warn(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" should have the exact same param named \"${key.name}\"`);\r\n    }\r\n}\r\nfunction checkMissingParamsInAbsolutePath(record, parent) {\r\n    for (const key of parent.keys) {\r\n        if (!record.keys.find(isSameParam.bind(null, key)))\r\n            return warn(`Absolute path \"${record.record.path}\" should have the exact same param named \"${key.name}\" as its parent \"${parent.record.path}\".`);\r\n    }\r\n}\r\nfunction isRecordChildOf(record, parent) {\r\n    return parent.children.some(child => child === record || isRecordChildOf(record, child));\r\n}\n\n/**\r\n * Encoding Rules  = Space Path:  \" < > # ? { } Query:  \" < > # & = Hash:  \"\r\n * < > `\r\n *\r\n * On top of that, the RFC3986 (https://tools.ietf.org/html/rfc3986#section-2.2)\r\n * defines some extra characters to be encoded. Most browsers do not encode them\r\n * in encodeURI https://github.com/whatwg/url/issues/369, so it may be safer to\r\n * also encode `!'()*`. Leaving unencoded only ASCII alphanumeric(`a-zA-Z0-9`)\r\n * plus `-._~`. This extra safety should be applied to query by patching the\r\n * string returned by encodeURIComponent encodeURI also encodes `[\\]^`. `\\`\r\n * should be encoded to avoid ambiguity. Browsers (IE, FF, C) transform a `\\`\r\n * into a `/` if directly typed in. The _backtick_ (`````) should also be\r\n * encoded everywhere because some browsers like FF encode it when directly\r\n * written while others don't. Safari and IE don't encode ``\"<>{}``` in hash.\r\n */\r\n// const EXTRA_RESERVED_RE = /[!'()*]/g\r\n// const encodeReservedReplacer = (c: string) => '%' + c.charCodeAt(0).toString(16)\r\nconst HASH_RE = /#/g; // %23\r\nconst AMPERSAND_RE = /&/g; // %26\r\nconst SLASH_RE = /\\//g; // %2F\r\nconst EQUAL_RE = /=/g; // %3D\r\nconst IM_RE = /\\?/g; // %3F\r\nconst PLUS_RE = /\\+/g; // %2B\r\n/**\r\n * NOTE: It's not clear to me if we should encode the + symbol in queries, it\r\n * seems to be less flexible than not doing so and I can't find out the legacy\r\n * systems requiring this for regular requests like text/html. In the standard,\r\n * the encoding of the plus character is only mentioned for\r\n * application/x-www-form-urlencoded\r\n * (https://url.spec.whatwg.org/#urlencoded-parsing) and most browsers seems lo\r\n * leave the plus character as is in queries. To be more flexible, we allow the\r\n * plus character on the query but it can also be manually encoded by the user.\r\n *\r\n * Resources:\r\n * - https://url.spec.whatwg.org/#urlencoded-parsing\r\n * - https://stackoverflow.com/questions/1634271/url-encoding-the-space-character-or-20\r\n */\r\nconst ENC_BRACKET_OPEN_RE = /%5B/g; // [\r\nconst ENC_BRACKET_CLOSE_RE = /%5D/g; // ]\r\nconst ENC_CARET_RE = /%5E/g; // ^\r\nconst ENC_BACKTICK_RE = /%60/g; // `\r\nconst ENC_CURLY_OPEN_RE = /%7B/g; // {\r\nconst ENC_PIPE_RE = /%7C/g; // |\r\nconst ENC_CURLY_CLOSE_RE = /%7D/g; // }\r\nconst ENC_SPACE_RE = /%20/g; // }\r\n/**\r\n * Encode characters that need to be encoded on the path, search and hash\r\n * sections of the URL.\r\n *\r\n * @internal\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction commonEncode(text) {\r\n    return encodeURI('' + text)\r\n        .replace(ENC_PIPE_RE, '|')\r\n        .replace(ENC_BRACKET_OPEN_RE, '[')\r\n        .replace(ENC_BRACKET_CLOSE_RE, ']');\r\n}\r\n/**\r\n * Encode characters that need to be encoded on the hash section of the URL.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction encodeHash(text) {\r\n    return commonEncode(text)\r\n        .replace(ENC_CURLY_OPEN_RE, '{')\r\n        .replace(ENC_CURLY_CLOSE_RE, '}')\r\n        .replace(ENC_CARET_RE, '^');\r\n}\r\n/**\r\n * Encode characters that need to be encoded query values on the query\r\n * section of the URL.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction encodeQueryValue(text) {\r\n    return (commonEncode(text)\r\n        // Encode the space as +, encode the + to differentiate it from the space\r\n        .replace(PLUS_RE, '%2B')\r\n        .replace(ENC_SPACE_RE, '+')\r\n        .replace(HASH_RE, '%23')\r\n        .replace(AMPERSAND_RE, '%26')\r\n        .replace(ENC_BACKTICK_RE, '`')\r\n        .replace(ENC_CURLY_OPEN_RE, '{')\r\n        .replace(ENC_CURLY_CLOSE_RE, '}')\r\n        .replace(ENC_CARET_RE, '^'));\r\n}\r\n/**\r\n * Like `encodeQueryValue` but also encodes the `=` character.\r\n *\r\n * @param text - string to encode\r\n */\r\nfunction encodeQueryKey(text) {\r\n    return encodeQueryValue(text).replace(EQUAL_RE, '%3D');\r\n}\r\n/**\r\n * Encode characters that need to be encoded on the path section of the URL.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction encodePath(text) {\r\n    return commonEncode(text).replace(HASH_RE, '%23').replace(IM_RE, '%3F');\r\n}\r\n/**\r\n * Encode characters that need to be encoded on the path section of the URL as a\r\n * param. This function encodes everything {@link encodePath} does plus the\r\n * slash (`/`) character. If `text` is `null` or `undefined`, returns an empty\r\n * string instead.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction encodeParam(text) {\r\n    return text == null ? '' : encodePath(text).replace(SLASH_RE, '%2F');\r\n}\r\n/**\r\n * Decode text using `decodeURIComponent`. Returns the original text if it\r\n * fails.\r\n *\r\n * @param text - string to decode\r\n * @returns decoded string\r\n */\r\nfunction decode(text) {\r\n    try {\r\n        return decodeURIComponent('' + text);\r\n    }\r\n    catch (err) {\r\n        (process.env.NODE_ENV !== 'production') && warn(`Error decoding \"${text}\". Using original value`);\r\n    }\r\n    return '' + text;\r\n}\n\n/**\r\n * Transforms a queryString into a {@link LocationQuery} object. Accept both, a\r\n * version with the leading `?` and without Should work as URLSearchParams\r\n\n * @internal\r\n *\r\n * @param search - search string to parse\r\n * @returns a query object\r\n */\r\nfunction parseQuery(search) {\r\n    const query = {};\r\n    // avoid creating an object with an empty key and empty value\r\n    // because of split('&')\r\n    if (search === '' || search === '?')\r\n        return query;\r\n    const hasLeadingIM = search[0] === '?';\r\n    const searchParams = (hasLeadingIM ? search.slice(1) : search).split('&');\r\n    for (let i = 0; i < searchParams.length; ++i) {\r\n        // pre decode the + into space\r\n        const searchParam = searchParams[i].replace(PLUS_RE, ' ');\r\n        // allow the = character\r\n        const eqPos = searchParam.indexOf('=');\r\n        const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));\r\n        const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));\r\n        if (key in query) {\r\n            // an extra variable for ts types\r\n            let currentValue = query[key];\r\n            if (!Array.isArray(currentValue)) {\r\n                currentValue = query[key] = [currentValue];\r\n            }\r\n            currentValue.push(value);\r\n        }\r\n        else {\r\n            query[key] = value;\r\n        }\r\n    }\r\n    return query;\r\n}\r\n/**\r\n * Stringifies a {@link LocationQueryRaw} object. Like `URLSearchParams`, it\r\n * doesn't prepend a `?`\r\n *\r\n * @internal\r\n *\r\n * @param query - query object to stringify\r\n * @returns string version of the query without the leading `?`\r\n */\r\nfunction stringifyQuery(query) {\r\n    let search = '';\r\n    for (let key in query) {\r\n        const value = query[key];\r\n        key = encodeQueryKey(key);\r\n        if (value == null) {\r\n            // only null adds the value\r\n            if (value !== undefined) {\r\n                search += (search.length ? '&' : '') + key;\r\n            }\r\n            continue;\r\n        }\r\n        // keep null values\r\n        const values = Array.isArray(value)\r\n            ? value.map(v => v && encodeQueryValue(v))\r\n            : [value && encodeQueryValue(value)];\r\n        values.forEach(value => {\r\n            // skip undefined values in arrays as if they were not present\r\n            // smaller code than using filter\r\n            if (value !== undefined) {\r\n                // only append & with non-empty search\r\n                search += (search.length ? '&' : '') + key;\r\n                if (value != null)\r\n                    search += '=' + value;\r\n            }\r\n        });\r\n    }\r\n    return search;\r\n}\r\n/**\r\n * Transforms a {@link LocationQueryRaw} into a {@link LocationQuery} by casting\r\n * numbers into strings, removing keys with an undefined value and replacing\r\n * undefined with null in arrays\r\n *\r\n * @param query - query object to normalize\r\n * @returns a normalized query object\r\n */\r\nfunction normalizeQuery(query) {\r\n    const normalizedQuery = {};\r\n    for (const key in query) {\r\n        const value = query[key];\r\n        if (value !== undefined) {\r\n            normalizedQuery[key] = Array.isArray(value)\r\n                ? value.map(v => (v == null ? null : '' + v))\r\n                : value == null\r\n                    ? value\r\n                    : '' + value;\r\n        }\r\n    }\r\n    return normalizedQuery;\r\n}\n\n/**\r\n * Create a list of callbacks that can be reset. Used to create before and after navigation guards list\r\n */\r\nfunction useCallbacks() {\r\n    let handlers = [];\r\n    function add(handler) {\r\n        handlers.push(handler);\r\n        return () => {\r\n            const i = handlers.indexOf(handler);\r\n            if (i > -1)\r\n                handlers.splice(i, 1);\r\n        };\r\n    }\r\n    function reset() {\r\n        handlers = [];\r\n    }\r\n    return {\r\n        add,\r\n        list: () => handlers,\r\n        reset,\r\n    };\r\n}\n\nfunction registerGuard(record, name, guard) {\r\n    const removeFromList = () => {\r\n        record[name].delete(guard);\r\n    };\r\n    onUnmounted(removeFromList);\r\n    onDeactivated(removeFromList);\r\n    onActivated(() => {\r\n        record[name].add(guard);\r\n    });\r\n    record[name].add(guard);\r\n}\r\n/**\r\n * Add a navigation guard that triggers whenever the component for the current\r\n * location is about to be left. Similar to {@link beforeRouteLeave} but can be\r\n * used in any component. The guard is removed when the component is unmounted.\r\n *\r\n * @param leaveGuard - {@link NavigationGuard}\r\n */\r\nfunction onBeforeRouteLeave(leaveGuard) {\r\n    if ((process.env.NODE_ENV !== 'production') && !getCurrentInstance()) {\r\n        warn('getCurrentInstance() returned null. onBeforeRouteLeave() must be called at the top of a setup function');\r\n        return;\r\n    }\r\n    const activeRecord = inject(matchedRouteKey, \r\n    // to avoid warning\r\n    {}).value;\r\n    if (!activeRecord) {\r\n        (process.env.NODE_ENV !== 'production') &&\r\n            warn('No active route record was found when calling `onBeforeRouteLeave()`. Make sure you call this function inside of a component child of <router-view>. Maybe you called it inside of App.vue?');\r\n        return;\r\n    }\r\n    registerGuard(activeRecord, 'leaveGuards', leaveGuard);\r\n}\r\n/**\r\n * Add a navigation guard that triggers whenever the current location is about\r\n * to be updated. Similar to {@link beforeRouteUpdate} but can be used in any\r\n * component. The guard is removed when the component is unmounted.\r\n *\r\n * @param updateGuard - {@link NavigationGuard}\r\n */\r\nfunction onBeforeRouteUpdate(updateGuard) {\r\n    if ((process.env.NODE_ENV !== 'production') && !getCurrentInstance()) {\r\n        warn('getCurrentInstance() returned null. onBeforeRouteUpdate() must be called at the top of a setup function');\r\n        return;\r\n    }\r\n    const activeRecord = inject(matchedRouteKey, \r\n    // to avoid warning\r\n    {}).value;\r\n    if (!activeRecord) {\r\n        (process.env.NODE_ENV !== 'production') &&\r\n            warn('No active route record was found when calling `onBeforeRouteUpdate()`. Make sure you call this function inside of a component child of <router-view>. Maybe you called it inside of App.vue?');\r\n        return;\r\n    }\r\n    registerGuard(activeRecord, 'updateGuards', updateGuard);\r\n}\r\nfunction guardToPromiseFn(guard, to, from, record, name) {\r\n    // keep a reference to the enterCallbackArray to prevent pushing callbacks if a new navigation took place\r\n    const enterCallbackArray = record &&\r\n        // name is defined if record is because of the function overload\r\n        (record.enterCallbacks[name] = record.enterCallbacks[name] || []);\r\n    return () => new Promise((resolve, reject) => {\r\n        const next = (valid) => {\r\n            if (valid === false)\r\n                reject(createRouterError(4 /* NAVIGATION_ABORTED */, {\r\n                    from,\r\n                    to,\r\n                }));\r\n            else if (valid instanceof Error) {\r\n                reject(valid);\r\n            }\r\n            else if (isRouteLocation(valid)) {\r\n                reject(createRouterError(2 /* NAVIGATION_GUARD_REDIRECT */, {\r\n                    from: to,\r\n                    to: valid,\r\n                }));\r\n            }\r\n            else {\r\n                if (enterCallbackArray &&\r\n                    // since enterCallbackArray is truthy, both record and name also are\r\n                    record.enterCallbacks[name] === enterCallbackArray &&\r\n                    typeof valid === 'function')\r\n                    enterCallbackArray.push(valid);\r\n                resolve();\r\n            }\r\n        };\r\n        // wrapping with Promise.resolve allows it to work with both async and sync guards\r\n        const guardReturn = guard.call(record && record.instances[name], to, from, (process.env.NODE_ENV !== 'production') ? canOnlyBeCalledOnce(next, to, from) : next);\r\n        let guardCall = Promise.resolve(guardReturn);\r\n        if (guard.length < 3)\r\n            guardCall = guardCall.then(next);\r\n        if ((process.env.NODE_ENV !== 'production') && guard.length > 2) {\r\n            const message = `The \"next\" callback was never called inside of ${guard.name ? '\"' + guard.name + '\"' : ''}:\\n${guard.toString()}\\n. If you are returning a value instead of calling \"next\", make sure to remove the \"next\" parameter from your function.`;\r\n            if (typeof guardReturn === 'object' && 'then' in guardReturn) {\r\n                guardCall = guardCall.then(resolvedValue => {\r\n                    // @ts-expect-error: _called is added at canOnlyBeCalledOnce\r\n                    if (!next._called) {\r\n                        warn(message);\r\n                        return Promise.reject(new Error('Invalid navigation guard'));\r\n                    }\r\n                    return resolvedValue;\r\n                });\r\n                // TODO: test me!\r\n            }\r\n            else if (guardReturn !== undefined) {\r\n                // @ts-expect-error: _called is added at canOnlyBeCalledOnce\r\n                if (!next._called) {\r\n                    warn(message);\r\n                    reject(new Error('Invalid navigation guard'));\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        guardCall.catch(err => reject(err));\r\n    });\r\n}\r\nfunction canOnlyBeCalledOnce(next, to, from) {\r\n    let called = 0;\r\n    return function () {\r\n        if (called++ === 1)\r\n            warn(`The \"next\" callback was called more than once in one navigation guard when going from \"${from.fullPath}\" to \"${to.fullPath}\". It should be called exactly one time in each navigation guard. This will fail in production.`);\r\n        // @ts-expect-error: we put it in the original one because it's easier to check\r\n        next._called = true;\r\n        if (called === 1)\r\n            next.apply(null, arguments);\r\n    };\r\n}\r\nfunction extractComponentsGuards(matched, guardType, to, from) {\r\n    const guards = [];\r\n    for (const record of matched) {\r\n        for (const name in record.components) {\r\n            let rawComponent = record.components[name];\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                if (!rawComponent ||\r\n                    (typeof rawComponent !== 'object' &&\r\n                        typeof rawComponent !== 'function')) {\r\n                    warn(`Component \"${name}\" in record with path \"${record.path}\" is not` +\r\n                        ` a valid component. Received \"${String(rawComponent)}\".`);\r\n                    // throw to ensure we stop here but warn to ensure the message isn't\r\n                    // missed by the user\r\n                    throw new Error('Invalid route component');\r\n                }\r\n                else if ('then' in rawComponent) {\r\n                    // warn if user wrote import('/component.vue') instead of () =>\r\n                    // import('./component.vue')\r\n                    warn(`Component \"${name}\" in record with path \"${record.path}\" is a ` +\r\n                        `Promise instead of a function that returns a Promise. Did you ` +\r\n                        `write \"import('./MyPage.vue')\" instead of ` +\r\n                        `\"() => import('./MyPage.vue')\" ? This will break in ` +\r\n                        `production if not fixed.`);\r\n                    const promise = rawComponent;\r\n                    rawComponent = () => promise;\r\n                }\r\n                else if (rawComponent.__asyncLoader &&\r\n                    // warn only once per component\r\n                    !rawComponent.__warnedDefineAsync) {\r\n                    rawComponent.__warnedDefineAsync = true;\r\n                    warn(`Component \"${name}\" in record with path \"${record.path}\" is defined ` +\r\n                        `using \"defineAsyncComponent()\". ` +\r\n                        `Write \"() => import('./MyPage.vue')\" instead of ` +\r\n                        `\"defineAsyncComponent(() => import('./MyPage.vue'))\".`);\r\n                }\r\n            }\r\n            // skip update and leave guards if the route component is not mounted\r\n            if (guardType !== 'beforeRouteEnter' && !record.instances[name])\r\n                continue;\r\n            if (isRouteComponent(rawComponent)) {\r\n                // __vccOpts is added by vue-class-component and contain the regular options\r\n                const options = rawComponent.__vccOpts || rawComponent;\r\n                const guard = options[guardType];\r\n                guard && guards.push(guardToPromiseFn(guard, to, from, record, name));\r\n            }\r\n            else {\r\n                // start requesting the chunk already\r\n                let componentPromise = rawComponent();\r\n                if ((process.env.NODE_ENV !== 'production') && !('catch' in componentPromise)) {\r\n                    warn(`Component \"${name}\" in record with path \"${record.path}\" is a function that does not return a Promise. If you were passing a functional component, make sure to add a \"displayName\" to the component. This will break in production if not fixed.`);\r\n                    componentPromise = Promise.resolve(componentPromise);\r\n                }\r\n                guards.push(() => componentPromise.then(resolved => {\r\n                    if (!resolved)\r\n                        return Promise.reject(new Error(`Couldn't resolve component \"${name}\" at \"${record.path}\"`));\r\n                    const resolvedComponent = isESModule(resolved)\r\n                        ? resolved.default\r\n                        : resolved;\r\n                    // replace the function with the resolved component\r\n                    record.components[name] = resolvedComponent;\r\n                    // __vccOpts is added by vue-class-component and contain the regular options\r\n                    const options = resolvedComponent.__vccOpts || resolvedComponent;\r\n                    const guard = options[guardType];\r\n                    return guard && guardToPromiseFn(guard, to, from, record, name)();\r\n                }));\r\n            }\r\n        }\r\n    }\r\n    return guards;\r\n}\r\n/**\r\n * Allows differentiating lazy components from functional components and vue-class-component\r\n *\r\n * @param component\r\n */\r\nfunction isRouteComponent(component) {\r\n    return (typeof component === 'object' ||\r\n        'displayName' in component ||\r\n        'props' in component ||\r\n        '__vccOpts' in component);\r\n}\n\n// TODO: we could allow currentRoute as a prop to expose `isActive` and\r\n// `isExactActive` behavior should go through an RFC\r\nfunction useLink(props) {\r\n    const router = inject(routerKey);\r\n    const currentRoute = inject(routeLocationKey);\r\n    const route = computed(() => router.resolve(unref(props.to)));\r\n    const activeRecordIndex = computed(() => {\r\n        const { matched } = route.value;\r\n        const { length } = matched;\r\n        const routeMatched = matched[length - 1];\r\n        const currentMatched = currentRoute.matched;\r\n        if (!routeMatched || !currentMatched.length)\r\n            return -1;\r\n        const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));\r\n        if (index > -1)\r\n            return index;\r\n        // possible parent record\r\n        const parentRecordPath = getOriginalPath(matched[length - 2]);\r\n        return (\r\n        // we are dealing with nested routes\r\n        length > 1 &&\r\n            // if the parent and matched route have the same path, this link is\r\n            // referring to the empty child. Or we currently are on a different\r\n            // child of the same parent\r\n            getOriginalPath(routeMatched) === parentRecordPath &&\r\n            // avoid comparing the child with its parent\r\n            currentMatched[currentMatched.length - 1].path !== parentRecordPath\r\n            ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2]))\r\n            : index);\r\n    });\r\n    const isActive = computed(() => activeRecordIndex.value > -1 &&\r\n        includesParams(currentRoute.params, route.value.params));\r\n    const isExactActive = computed(() => activeRecordIndex.value > -1 &&\r\n        activeRecordIndex.value === currentRoute.matched.length - 1 &&\r\n        isSameRouteLocationParams(currentRoute.params, route.value.params));\r\n    function navigate(e = {}) {\r\n        if (guardEvent(e)) {\r\n            return router[unref(props.replace) ? 'replace' : 'push'](unref(props.to)\r\n            // avoid uncaught errors are they are logged anyway\r\n            ).catch(noop);\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n    // devtools only\r\n    if (((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) && isBrowser) {\r\n        const instance = getCurrentInstance();\r\n        if (instance) {\r\n            const linkContextDevtools = {\r\n                route: route.value,\r\n                isActive: isActive.value,\r\n                isExactActive: isExactActive.value,\r\n            };\r\n            // @ts-expect-error: this is internal\r\n            instance.__vrl_devtools = instance.__vrl_devtools || [];\r\n            // @ts-expect-error: this is internal\r\n            instance.__vrl_devtools.push(linkContextDevtools);\r\n            watchEffect(() => {\r\n                linkContextDevtools.route = route.value;\r\n                linkContextDevtools.isActive = isActive.value;\r\n                linkContextDevtools.isExactActive = isExactActive.value;\r\n            }, { flush: 'post' });\r\n        }\r\n    }\r\n    return {\r\n        route,\r\n        href: computed(() => route.value.href),\r\n        isActive,\r\n        isExactActive,\r\n        navigate,\r\n    };\r\n}\r\nconst RouterLinkImpl = /*#__PURE__*/ defineComponent({\r\n    name: 'RouterLink',\r\n    props: {\r\n        to: {\r\n            type: [String, Object],\r\n            required: true,\r\n        },\r\n        replace: Boolean,\r\n        activeClass: String,\r\n        // inactiveClass: String,\r\n        exactActiveClass: String,\r\n        custom: Boolean,\r\n        ariaCurrentValue: {\r\n            type: String,\r\n            default: 'page',\r\n        },\r\n    },\r\n    useLink,\r\n    setup(props, { slots }) {\r\n        const link = reactive(useLink(props));\r\n        const { options } = inject(routerKey);\r\n        const elClass = computed(() => ({\r\n            [getLinkClass(props.activeClass, options.linkActiveClass, 'router-link-active')]: link.isActive,\r\n            // [getLinkClass(\r\n            //   props.inactiveClass,\r\n            //   options.linkInactiveClass,\r\n            //   'router-link-inactive'\r\n            // )]: !link.isExactActive,\r\n            [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, 'router-link-exact-active')]: link.isExactActive,\r\n        }));\r\n        return () => {\r\n            const children = slots.default && slots.default(link);\r\n            return props.custom\r\n                ? children\r\n                : h('a', {\r\n                    'aria-current': link.isExactActive\r\n                        ? props.ariaCurrentValue\r\n                        : null,\r\n                    href: link.href,\r\n                    // this would override user added attrs but Vue will still add\r\n                    // the listener so we end up triggering both\r\n                    onClick: link.navigate,\r\n                    class: elClass.value,\r\n                }, children);\r\n        };\r\n    },\r\n});\r\n// export the public type for h/tsx inference\r\n// also to avoid inline import() in generated d.ts files\r\n/**\r\n * Component to render a link that triggers a navigation on click.\r\n */\r\nconst RouterLink = RouterLinkImpl;\r\nfunction guardEvent(e) {\r\n    // don't redirect with control keys\r\n    if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\r\n        return;\r\n    // don't redirect when preventDefault called\r\n    if (e.defaultPrevented)\r\n        return;\r\n    // don't redirect on right click\r\n    if (e.button !== undefined && e.button !== 0)\r\n        return;\r\n    // don't redirect if `target=\"_blank\"`\r\n    // @ts-expect-error getAttribute does exist\r\n    if (e.currentTarget && e.currentTarget.getAttribute) {\r\n        // @ts-expect-error getAttribute exists\r\n        const target = e.currentTarget.getAttribute('target');\r\n        if (/\\b_blank\\b/i.test(target))\r\n            return;\r\n    }\r\n    // this may be a Weex event which doesn't have this method\r\n    if (e.preventDefault)\r\n        e.preventDefault();\r\n    return true;\r\n}\r\nfunction includesParams(outer, inner) {\r\n    for (const key in inner) {\r\n        const innerValue = inner[key];\r\n        const outerValue = outer[key];\r\n        if (typeof innerValue === 'string') {\r\n            if (innerValue !== outerValue)\r\n                return false;\r\n        }\r\n        else {\r\n            if (!Array.isArray(outerValue) ||\r\n                outerValue.length !== innerValue.length ||\r\n                innerValue.some((value, i) => value !== outerValue[i]))\r\n                return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Get the original path value of a record by following its aliasOf\r\n * @param record\r\n */\r\nfunction getOriginalPath(record) {\r\n    return record ? (record.aliasOf ? record.aliasOf.path : record.path) : '';\r\n}\r\n/**\r\n * Utility class to get the active class based on defaults.\r\n * @param propClass\r\n * @param globalClass\r\n * @param defaultClass\r\n */\r\nconst getLinkClass = (propClass, globalClass, defaultClass) => propClass != null\r\n    ? propClass\r\n    : globalClass != null\r\n        ? globalClass\r\n        : defaultClass;\n\nconst RouterViewImpl = /*#__PURE__*/ defineComponent({\r\n    name: 'RouterView',\r\n    // #674 we manually inherit them\r\n    inheritAttrs: false,\r\n    props: {\r\n        name: {\r\n            type: String,\r\n            default: 'default',\r\n        },\r\n        route: Object,\r\n    },\r\n    setup(props, { attrs, slots }) {\r\n        (process.env.NODE_ENV !== 'production') && warnDeprecatedUsage();\r\n        const injectedRoute = inject(routerViewLocationKey);\r\n        const routeToDisplay = computed(() => props.route || injectedRoute.value);\r\n        const depth = inject(viewDepthKey, 0);\r\n        const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth]);\r\n        provide(viewDepthKey, depth + 1);\r\n        provide(matchedRouteKey, matchedRouteRef);\r\n        provide(routerViewLocationKey, routeToDisplay);\r\n        const viewRef = ref();\r\n        // watch at the same time the component instance, the route record we are\r\n        // rendering, and the name\r\n        watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {\r\n            // copy reused instances\r\n            if (to) {\r\n                // this will update the instance for new instances as well as reused\r\n                // instances when navigating to a new route\r\n                to.instances[name] = instance;\r\n                // the component instance is reused for a different route or name so\r\n                // we copy any saved update or leave guards. With async setup, the\r\n                // mounting component will mount before the matchedRoute changes,\r\n                // making instance === oldInstance, so we check if guards have been\r\n                // added before. This works because we remove guards when\r\n                // unmounting/deactivating components\r\n                if (from && from !== to && instance && instance === oldInstance) {\r\n                    if (!to.leaveGuards.size) {\r\n                        to.leaveGuards = from.leaveGuards;\r\n                    }\r\n                    if (!to.updateGuards.size) {\r\n                        to.updateGuards = from.updateGuards;\r\n                    }\r\n                }\r\n            }\r\n            // trigger beforeRouteEnter next callbacks\r\n            if (instance &&\r\n                to &&\r\n                // if there is no instance but to and from are the same this might be\r\n                // the first visit\r\n                (!from || !isSameRouteRecord(to, from) || !oldInstance)) {\r\n                (to.enterCallbacks[name] || []).forEach(callback => callback(instance));\r\n            }\r\n        }, { flush: 'post' });\r\n        return () => {\r\n            const route = routeToDisplay.value;\r\n            const matchedRoute = matchedRouteRef.value;\r\n            const ViewComponent = matchedRoute && matchedRoute.components[props.name];\r\n            // we need the value at the time we render because when we unmount, we\r\n            // navigated to a different location so the value is different\r\n            const currentName = props.name;\r\n            if (!ViewComponent) {\r\n                return normalizeSlot(slots.default, { Component: ViewComponent, route });\r\n            }\r\n            // props from route configuration\r\n            const routePropsOption = matchedRoute.props[props.name];\r\n            const routeProps = routePropsOption\r\n                ? routePropsOption === true\r\n                    ? route.params\r\n                    : typeof routePropsOption === 'function'\r\n                        ? routePropsOption(route)\r\n                        : routePropsOption\r\n                : null;\r\n            const onVnodeUnmounted = vnode => {\r\n                // remove the instance reference to prevent leak\r\n                if (vnode.component.isUnmounted) {\r\n                    matchedRoute.instances[currentName] = null;\r\n                }\r\n            };\r\n            const component = h(ViewComponent, assign({}, routeProps, attrs, {\r\n                onVnodeUnmounted,\r\n                ref: viewRef,\r\n            }));\r\n            if (((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) &&\r\n                isBrowser &&\r\n                component.ref) {\r\n                // TODO: can display if it's an alias, its props\r\n                const info = {\r\n                    depth,\r\n                    name: matchedRoute.name,\r\n                    path: matchedRoute.path,\r\n                    meta: matchedRoute.meta,\r\n                };\r\n                const internalInstances = Array.isArray(component.ref)\r\n                    ? component.ref.map(r => r.i)\r\n                    : [component.ref.i];\r\n                internalInstances.forEach(instance => {\r\n                    // @ts-expect-error\r\n                    instance.__vrv_devtools = info;\r\n                });\r\n            }\r\n            return (\r\n            // pass the vnode to the slot as a prop.\r\n            // h and <component :is=\"...\"> both accept vnodes\r\n            normalizeSlot(slots.default, { Component: component, route }) ||\r\n                component);\r\n        };\r\n    },\r\n});\r\nfunction normalizeSlot(slot, data) {\r\n    if (!slot)\r\n        return null;\r\n    const slotContent = slot(data);\r\n    return slotContent.length === 1 ? slotContent[0] : slotContent;\r\n}\r\n// export the public type for h/tsx inference\r\n// also to avoid inline import() in generated d.ts files\r\n/**\r\n * Component to display the current route the user is at.\r\n */\r\nconst RouterView = RouterViewImpl;\r\n// warn against deprecated usage with <transition> & <keep-alive>\r\n// due to functional component being no longer eager in Vue 3\r\nfunction warnDeprecatedUsage() {\r\n    const instance = getCurrentInstance();\r\n    const parentName = instance.parent && instance.parent.type.name;\r\n    if (parentName &&\r\n        (parentName === 'KeepAlive' || parentName.includes('Transition'))) {\r\n        const comp = parentName === 'KeepAlive' ? 'keep-alive' : 'transition';\r\n        warn(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.\\n` +\r\n            `Use slot props instead:\\n\\n` +\r\n            `<router-view v-slot=\"{ Component }\">\\n` +\r\n            `  <${comp}>\\n` +\r\n            `    <component :is=\"Component\" />\\n` +\r\n            `  </${comp}>\\n` +\r\n            `</router-view>`);\r\n    }\r\n}\n\nfunction formatRouteLocation(routeLocation, tooltip) {\r\n    const copy = assign({}, routeLocation, {\r\n        // remove variables that can contain vue instances\r\n        matched: routeLocation.matched.map(matched => omit(matched, ['instances', 'children', 'aliasOf'])),\r\n    });\r\n    return {\r\n        _custom: {\r\n            type: null,\r\n            readOnly: true,\r\n            display: routeLocation.fullPath,\r\n            tooltip,\r\n            value: copy,\r\n        },\r\n    };\r\n}\r\nfunction formatDisplay(display) {\r\n    return {\r\n        _custom: {\r\n            display,\r\n        },\r\n    };\r\n}\r\n// to support multiple router instances\r\nlet routerId = 0;\r\nfunction addDevtools(app, router, matcher) {\r\n    // Take over router.beforeEach and afterEach\r\n    // make sure we are not registering the devtool twice\r\n    if (router.__hasDevtools)\r\n        return;\r\n    router.__hasDevtools = true;\r\n    // increment to support multiple router instances\r\n    const id = routerId++;\r\n    setupDevtoolsPlugin({\r\n        id: 'org.vuejs.router' + (id ? '.' + id : ''),\r\n        label: 'Vue Router',\r\n        packageName: 'vue-router',\r\n        homepage: 'https://router.vuejs.org',\r\n        logo: 'https://router.vuejs.org/logo.png',\r\n        componentStateTypes: ['Routing'],\r\n        app,\r\n    }, api => {\r\n        // display state added by the router\r\n        api.on.inspectComponent((payload, ctx) => {\r\n            if (payload.instanceData) {\r\n                payload.instanceData.state.push({\r\n                    type: 'Routing',\r\n                    key: '$route',\r\n                    editable: false,\r\n                    value: formatRouteLocation(router.currentRoute.value, 'Current Route'),\r\n                });\r\n            }\r\n        });\r\n        // mark router-link as active and display tags on router views\r\n        api.on.visitComponentTree(({ treeNode: node, componentInstance }) => {\r\n            if (componentInstance.__vrv_devtools) {\r\n                const info = componentInstance.__vrv_devtools;\r\n                node.tags.push({\r\n                    label: (info.name ? `${info.name.toString()}: ` : '') + info.path,\r\n                    textColor: 0,\r\n                    tooltip: 'This component is rendered by &lt;router-view&gt;',\r\n                    backgroundColor: PINK_500,\r\n                });\r\n            }\r\n            // if multiple useLink are used\r\n            if (Array.isArray(componentInstance.__vrl_devtools)) {\r\n                componentInstance.__devtoolsApi = api;\r\n                componentInstance.__vrl_devtools.forEach(devtoolsData => {\r\n                    let backgroundColor = ORANGE_400;\r\n                    let tooltip = '';\r\n                    if (devtoolsData.isExactActive) {\r\n                        backgroundColor = LIME_500;\r\n                        tooltip = 'This is exactly active';\r\n                    }\r\n                    else if (devtoolsData.isActive) {\r\n                        backgroundColor = BLUE_600;\r\n                        tooltip = 'This link is active';\r\n                    }\r\n                    node.tags.push({\r\n                        label: devtoolsData.route.path,\r\n                        textColor: 0,\r\n                        tooltip,\r\n                        backgroundColor,\r\n                    });\r\n                });\r\n            }\r\n        });\r\n        watch(router.currentRoute, () => {\r\n            // refresh active state\r\n            refreshRoutesView();\r\n            api.notifyComponentUpdate();\r\n            api.sendInspectorTree(routerInspectorId);\r\n            api.sendInspectorState(routerInspectorId);\r\n        });\r\n        const navigationsLayerId = 'router:navigations:' + id;\r\n        api.addTimelineLayer({\r\n            id: navigationsLayerId,\r\n            label: `Router${id ? ' ' + id : ''} Navigations`,\r\n            color: 0x40a8c4,\r\n        });\r\n        // const errorsLayerId = 'router:errors'\r\n        // api.addTimelineLayer({\r\n        //   id: errorsLayerId,\r\n        //   label: 'Router Errors',\r\n        //   color: 0xea5455,\r\n        // })\r\n        router.onError((error, to) => {\r\n            api.addTimelineEvent({\r\n                layerId: navigationsLayerId,\r\n                event: {\r\n                    title: 'Error during Navigation',\r\n                    subtitle: to.fullPath,\r\n                    logType: 'error',\r\n                    time: api.now(),\r\n                    data: { error },\r\n                    groupId: to.meta.__navigationId,\r\n                },\r\n            });\r\n        });\r\n        // attached to `meta` and used to group events\r\n        let navigationId = 0;\r\n        router.beforeEach((to, from) => {\r\n            const data = {\r\n                guard: formatDisplay('beforeEach'),\r\n                from: formatRouteLocation(from, 'Current Location during this navigation'),\r\n                to: formatRouteLocation(to, 'Target location'),\r\n            };\r\n            // Used to group navigations together, hide from devtools\r\n            Object.defineProperty(to.meta, '__navigationId', {\r\n                value: navigationId++,\r\n            });\r\n            api.addTimelineEvent({\r\n                layerId: navigationsLayerId,\r\n                event: {\r\n                    time: api.now(),\r\n                    title: 'Start of navigation',\r\n                    subtitle: to.fullPath,\r\n                    data,\r\n                    groupId: to.meta.__navigationId,\r\n                },\r\n            });\r\n        });\r\n        router.afterEach((to, from, failure) => {\r\n            const data = {\r\n                guard: formatDisplay('afterEach'),\r\n            };\r\n            if (failure) {\r\n                data.failure = {\r\n                    _custom: {\r\n                        type: Error,\r\n                        readOnly: true,\r\n                        display: failure ? failure.message : '',\r\n                        tooltip: 'Navigation Failure',\r\n                        value: failure,\r\n                    },\r\n                };\r\n                data.status = formatDisplay('');\r\n            }\r\n            else {\r\n                data.status = formatDisplay('');\r\n            }\r\n            // we set here to have the right order\r\n            data.from = formatRouteLocation(from, 'Current Location during this navigation');\r\n            data.to = formatRouteLocation(to, 'Target location');\r\n            api.addTimelineEvent({\r\n                layerId: navigationsLayerId,\r\n                event: {\r\n                    title: 'End of navigation',\r\n                    subtitle: to.fullPath,\r\n                    time: api.now(),\r\n                    data,\r\n                    logType: failure ? 'warning' : 'default',\r\n                    groupId: to.meta.__navigationId,\r\n                },\r\n            });\r\n        });\r\n        /**\r\n         * Inspector of Existing routes\r\n         */\r\n        const routerInspectorId = 'router-inspector:' + id;\r\n        api.addInspector({\r\n            id: routerInspectorId,\r\n            label: 'Routes' + (id ? ' ' + id : ''),\r\n            icon: 'book',\r\n            treeFilterPlaceholder: 'Search routes',\r\n        });\r\n        function refreshRoutesView() {\r\n            // the routes view isn't active\r\n            if (!activeRoutesPayload)\r\n                return;\r\n            const payload = activeRoutesPayload;\r\n            // children routes will appear as nested\r\n            let routes = matcher.getRoutes().filter(route => !route.parent);\r\n            // reset match state to false\r\n            routes.forEach(resetMatchStateOnRouteRecord);\r\n            // apply a match state if there is a payload\r\n            if (payload.filter) {\r\n                routes = routes.filter(route => \r\n                // save matches state based on the payload\r\n                isRouteMatching(route, payload.filter.toLowerCase()));\r\n            }\r\n            // mark active routes\r\n            routes.forEach(route => markRouteRecordActive(route, router.currentRoute.value));\r\n            payload.rootNodes = routes.map(formatRouteRecordForInspector);\r\n        }\r\n        let activeRoutesPayload;\r\n        api.on.getInspectorTree(payload => {\r\n            activeRoutesPayload = payload;\r\n            if (payload.app === app && payload.inspectorId === routerInspectorId) {\r\n                refreshRoutesView();\r\n            }\r\n        });\r\n        /**\r\n         * Display information about the currently selected route record\r\n         */\r\n        api.on.getInspectorState(payload => {\r\n            if (payload.app === app && payload.inspectorId === routerInspectorId) {\r\n                const routes = matcher.getRoutes();\r\n                const route = routes.find(route => route.record.__vd_id === payload.nodeId);\r\n                if (route) {\r\n                    payload.state = {\r\n                        options: formatRouteRecordMatcherForStateInspector(route),\r\n                    };\r\n                }\r\n            }\r\n        });\r\n        api.sendInspectorTree(routerInspectorId);\r\n        api.sendInspectorState(routerInspectorId);\r\n    });\r\n}\r\nfunction modifierForKey(key) {\r\n    if (key.optional) {\r\n        return key.repeatable ? '*' : '?';\r\n    }\r\n    else {\r\n        return key.repeatable ? '+' : '';\r\n    }\r\n}\r\nfunction formatRouteRecordMatcherForStateInspector(route) {\r\n    const { record } = route;\r\n    const fields = [\r\n        { editable: false, key: 'path', value: record.path },\r\n    ];\r\n    if (record.name != null) {\r\n        fields.push({\r\n            editable: false,\r\n            key: 'name',\r\n            value: record.name,\r\n        });\r\n    }\r\n    fields.push({ editable: false, key: 'regexp', value: route.re });\r\n    if (route.keys.length) {\r\n        fields.push({\r\n            editable: false,\r\n            key: 'keys',\r\n            value: {\r\n                _custom: {\r\n                    type: null,\r\n                    readOnly: true,\r\n                    display: route.keys\r\n                        .map(key => `${key.name}${modifierForKey(key)}`)\r\n                        .join(' '),\r\n                    tooltip: 'Param keys',\r\n                    value: route.keys,\r\n                },\r\n            },\r\n        });\r\n    }\r\n    if (record.redirect != null) {\r\n        fields.push({\r\n            editable: false,\r\n            key: 'redirect',\r\n            value: record.redirect,\r\n        });\r\n    }\r\n    if (route.alias.length) {\r\n        fields.push({\r\n            editable: false,\r\n            key: 'aliases',\r\n            value: route.alias.map(alias => alias.record.path),\r\n        });\r\n    }\r\n    fields.push({\r\n        key: 'score',\r\n        editable: false,\r\n        value: {\r\n            _custom: {\r\n                type: null,\r\n                readOnly: true,\r\n                display: route.score.map(score => score.join(', ')).join(' | '),\r\n                tooltip: 'Score used to sort routes',\r\n                value: route.score,\r\n            },\r\n        },\r\n    });\r\n    return fields;\r\n}\r\n/**\r\n * Extracted from tailwind palette\r\n */\r\nconst PINK_500 = 0xec4899;\r\nconst BLUE_600 = 0x2563eb;\r\nconst LIME_500 = 0x84cc16;\r\nconst CYAN_400 = 0x22d3ee;\r\nconst ORANGE_400 = 0xfb923c;\r\n// const GRAY_100 = 0xf4f4f5\r\nconst DARK = 0x666666;\r\nfunction formatRouteRecordForInspector(route) {\r\n    const tags = [];\r\n    const { record } = route;\r\n    if (record.name != null) {\r\n        tags.push({\r\n            label: String(record.name),\r\n            textColor: 0,\r\n            backgroundColor: CYAN_400,\r\n        });\r\n    }\r\n    if (record.aliasOf) {\r\n        tags.push({\r\n            label: 'alias',\r\n            textColor: 0,\r\n            backgroundColor: ORANGE_400,\r\n        });\r\n    }\r\n    if (route.__vd_match) {\r\n        tags.push({\r\n            label: 'matches',\r\n            textColor: 0,\r\n            backgroundColor: PINK_500,\r\n        });\r\n    }\r\n    if (route.__vd_exactActive) {\r\n        tags.push({\r\n            label: 'exact',\r\n            textColor: 0,\r\n            backgroundColor: LIME_500,\r\n        });\r\n    }\r\n    if (route.__vd_active) {\r\n        tags.push({\r\n            label: 'active',\r\n            textColor: 0,\r\n            backgroundColor: BLUE_600,\r\n        });\r\n    }\r\n    if (record.redirect) {\r\n        tags.push({\r\n            label: 'redirect: ' +\r\n                (typeof record.redirect === 'string' ? record.redirect : 'Object'),\r\n            textColor: 0xffffff,\r\n            backgroundColor: DARK,\r\n        });\r\n    }\r\n    // add an id to be able to select it. Using the `path` is not possible because\r\n    // empty path children would collide with their parents\r\n    let id = record.__vd_id;\r\n    if (id == null) {\r\n        id = String(routeRecordId++);\r\n        record.__vd_id = id;\r\n    }\r\n    return {\r\n        id,\r\n        label: record.path,\r\n        tags,\r\n        children: route.children.map(formatRouteRecordForInspector),\r\n    };\r\n}\r\n//  incremental id for route records and inspector state\r\nlet routeRecordId = 0;\r\nconst EXTRACT_REGEXP_RE = /^\\/(.*)\\/([a-z]*)$/;\r\nfunction markRouteRecordActive(route, currentRoute) {\r\n    // no route will be active if matched is empty\r\n    // reset the matching state\r\n    const isExactActive = currentRoute.matched.length &&\r\n        isSameRouteRecord(currentRoute.matched[currentRoute.matched.length - 1], route.record);\r\n    route.__vd_exactActive = route.__vd_active = isExactActive;\r\n    if (!isExactActive) {\r\n        route.__vd_active = currentRoute.matched.some(match => isSameRouteRecord(match, route.record));\r\n    }\r\n    route.children.forEach(childRoute => markRouteRecordActive(childRoute, currentRoute));\r\n}\r\nfunction resetMatchStateOnRouteRecord(route) {\r\n    route.__vd_match = false;\r\n    route.children.forEach(resetMatchStateOnRouteRecord);\r\n}\r\nfunction isRouteMatching(route, filter) {\r\n    const found = String(route.re).match(EXTRACT_REGEXP_RE);\r\n    route.__vd_match = false;\r\n    if (!found || found.length < 3) {\r\n        return false;\r\n    }\r\n    // use a regexp without $ at the end to match nested routes better\r\n    const nonEndingRE = new RegExp(found[1].replace(/\\$$/, ''), found[2]);\r\n    if (nonEndingRE.test(filter)) {\r\n        // mark children as matches\r\n        route.children.forEach(child => isRouteMatching(child, filter));\r\n        // exception case: `/`\r\n        if (route.record.path !== '/' || filter === '/') {\r\n            route.__vd_match = route.re.test(filter);\r\n            return true;\r\n        }\r\n        // hide the / route\r\n        return false;\r\n    }\r\n    const path = route.record.path.toLowerCase();\r\n    const decodedPath = decode(path);\r\n    // also allow partial matching on the path\r\n    if (!filter.startsWith('/') &&\r\n        (decodedPath.includes(filter) || path.includes(filter)))\r\n        return true;\r\n    if (decodedPath.startsWith(filter) || path.startsWith(filter))\r\n        return true;\r\n    if (route.record.name && String(route.record.name).includes(filter))\r\n        return true;\r\n    return route.children.some(child => isRouteMatching(child, filter));\r\n}\r\nfunction omit(obj, keys) {\r\n    const ret = {};\r\n    for (const key in obj) {\r\n        if (!keys.includes(key)) {\r\n            // @ts-expect-error\r\n            ret[key] = obj[key];\r\n        }\r\n    }\r\n    return ret;\r\n}\n\n/**\r\n * Creates a Router instance that can be used by a Vue app.\r\n *\r\n * @param options - {@link RouterOptions}\r\n */\r\nfunction createRouter(options) {\r\n    const matcher = createRouterMatcher(options.routes, options);\r\n    const parseQuery$1 = options.parseQuery || parseQuery;\r\n    const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;\r\n    const routerHistory = options.history;\r\n    if ((process.env.NODE_ENV !== 'production') && !routerHistory)\r\n        throw new Error('Provide the \"history\" option when calling \"createRouter()\":' +\r\n            ' https://next.router.vuejs.org/api/#history.');\r\n    const beforeGuards = useCallbacks();\r\n    const beforeResolveGuards = useCallbacks();\r\n    const afterGuards = useCallbacks();\r\n    const currentRoute = shallowRef(START_LOCATION_NORMALIZED);\r\n    let pendingLocation = START_LOCATION_NORMALIZED;\r\n    // leave the scrollRestoration if no scrollBehavior is provided\r\n    if (isBrowser && options.scrollBehavior && 'scrollRestoration' in history) {\r\n        history.scrollRestoration = 'manual';\r\n    }\r\n    const normalizeParams = applyToParams.bind(null, paramValue => '' + paramValue);\r\n    const encodeParams = applyToParams.bind(null, encodeParam);\r\n    const decodeParams = \r\n    // @ts-expect-error: intentionally avoid the type check\r\n    applyToParams.bind(null, decode);\r\n    function addRoute(parentOrRoute, route) {\r\n        let parent;\r\n        let record;\r\n        if (isRouteName(parentOrRoute)) {\r\n            parent = matcher.getRecordMatcher(parentOrRoute);\r\n            record = route;\r\n        }\r\n        else {\r\n            record = parentOrRoute;\r\n        }\r\n        return matcher.addRoute(record, parent);\r\n    }\r\n    function removeRoute(name) {\r\n        const recordMatcher = matcher.getRecordMatcher(name);\r\n        if (recordMatcher) {\r\n            matcher.removeRoute(recordMatcher);\r\n        }\r\n        else if ((process.env.NODE_ENV !== 'production')) {\r\n            warn(`Cannot remove non-existent route \"${String(name)}\"`);\r\n        }\r\n    }\r\n    function getRoutes() {\r\n        return matcher.getRoutes().map(routeMatcher => routeMatcher.record);\r\n    }\r\n    function hasRoute(name) {\r\n        return !!matcher.getRecordMatcher(name);\r\n    }\r\n    function resolve(rawLocation, currentLocation) {\r\n        // const objectLocation = routerLocationAsObject(rawLocation)\r\n        // we create a copy to modify it later\r\n        currentLocation = assign({}, currentLocation || currentRoute.value);\r\n        if (typeof rawLocation === 'string') {\r\n            const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);\r\n            const matchedRoute = matcher.resolve({ path: locationNormalized.path }, currentLocation);\r\n            const href = routerHistory.createHref(locationNormalized.fullPath);\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                if (href.startsWith('//'))\r\n                    warn(`Location \"${rawLocation}\" resolved to \"${href}\". A resolved location cannot start with multiple slashes.`);\r\n                else if (!matchedRoute.matched.length) {\r\n                    warn(`No match found for location with path \"${rawLocation}\"`);\r\n                }\r\n            }\r\n            // locationNormalized is always a new object\r\n            return assign(locationNormalized, matchedRoute, {\r\n                params: decodeParams(matchedRoute.params),\r\n                hash: decode(locationNormalized.hash),\r\n                redirectedFrom: undefined,\r\n                href,\r\n            });\r\n        }\r\n        let matcherLocation;\r\n        // path could be relative in object as well\r\n        if ('path' in rawLocation) {\r\n            if ((process.env.NODE_ENV !== 'production') &&\r\n                'params' in rawLocation &&\r\n                !('name' in rawLocation) &&\r\n                // @ts-expect-error: the type is never\r\n                Object.keys(rawLocation.params).length) {\r\n                warn(`Path \"${\r\n                // @ts-expect-error: the type is never\r\n                rawLocation.path}\" was passed with params but they will be ignored. Use a named route alongside params instead.`);\r\n            }\r\n            matcherLocation = assign({}, rawLocation, {\r\n                path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path,\r\n            });\r\n        }\r\n        else {\r\n            // remove any nullish param\r\n            const targetParams = assign({}, rawLocation.params);\r\n            for (const key in targetParams) {\r\n                if (targetParams[key] == null) {\r\n                    delete targetParams[key];\r\n                }\r\n            }\r\n            // pass encoded values to the matcher so it can produce encoded path and fullPath\r\n            matcherLocation = assign({}, rawLocation, {\r\n                params: encodeParams(rawLocation.params),\r\n            });\r\n            // current location params are decoded, we need to encode them in case the\r\n            // matcher merges the params\r\n            currentLocation.params = encodeParams(currentLocation.params);\r\n        }\r\n        const matchedRoute = matcher.resolve(matcherLocation, currentLocation);\r\n        const hash = rawLocation.hash || '';\r\n        if ((process.env.NODE_ENV !== 'production') && hash && !hash.startsWith('#')) {\r\n            warn(`A \\`hash\\` should always start with the character \"#\". Replace \"${hash}\" with \"#${hash}\".`);\r\n        }\r\n        // decoding them) the matcher might have merged current location params so\r\n        // we need to run the decoding again\r\n        matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));\r\n        const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {\r\n            hash: encodeHash(hash),\r\n            path: matchedRoute.path,\r\n        }));\r\n        const href = routerHistory.createHref(fullPath);\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            if (href.startsWith('//')) {\r\n                warn(`Location \"${rawLocation}\" resolved to \"${href}\". A resolved location cannot start with multiple slashes.`);\r\n            }\r\n            else if (!matchedRoute.matched.length) {\r\n                warn(`No match found for location with path \"${'path' in rawLocation ? rawLocation.path : rawLocation}\"`);\r\n            }\r\n        }\r\n        return assign({\r\n            fullPath,\r\n            // keep the hash encoded so fullPath is effectively path + encodedQuery +\r\n            // hash\r\n            hash,\r\n            query: \r\n            // if the user is using a custom query lib like qs, we might have\r\n            // nested objects, so we keep the query as is, meaning it can contain\r\n            // numbers at `$route.query`, but at the point, the user will have to\r\n            // use their own type anyway.\r\n            // https://github.com/vuejs/router/issues/328#issuecomment-649481567\r\n            stringifyQuery$1 === stringifyQuery\r\n                ? normalizeQuery(rawLocation.query)\r\n                : (rawLocation.query || {}),\r\n        }, matchedRoute, {\r\n            redirectedFrom: undefined,\r\n            href,\r\n        });\r\n    }\r\n    function locationAsObject(to) {\r\n        return typeof to === 'string'\r\n            ? parseURL(parseQuery$1, to, currentRoute.value.path)\r\n            : assign({}, to);\r\n    }\r\n    function checkCanceledNavigation(to, from) {\r\n        if (pendingLocation !== to) {\r\n            return createRouterError(8 /* NAVIGATION_CANCELLED */, {\r\n                from,\r\n                to,\r\n            });\r\n        }\r\n    }\r\n    function push(to) {\r\n        return pushWithRedirect(to);\r\n    }\r\n    function replace(to) {\r\n        return push(assign(locationAsObject(to), { replace: true }));\r\n    }\r\n    function handleRedirectRecord(to) {\r\n        const lastMatched = to.matched[to.matched.length - 1];\r\n        if (lastMatched && lastMatched.redirect) {\r\n            const { redirect } = lastMatched;\r\n            let newTargetLocation = typeof redirect === 'function' ? redirect(to) : redirect;\r\n            if (typeof newTargetLocation === 'string') {\r\n                newTargetLocation =\r\n                    newTargetLocation.includes('?') || newTargetLocation.includes('#')\r\n                        ? (newTargetLocation = locationAsObject(newTargetLocation))\r\n                        : // force empty params\r\n                            { path: newTargetLocation };\r\n                // @ts-expect-error: force empty params when a string is passed to let\r\n                // the router parse them again\r\n                newTargetLocation.params = {};\r\n            }\r\n            if ((process.env.NODE_ENV !== 'production') &&\r\n                !('path' in newTargetLocation) &&\r\n                !('name' in newTargetLocation)) {\r\n                warn(`Invalid redirect found:\\n${JSON.stringify(newTargetLocation, null, 2)}\\n when navigating to \"${to.fullPath}\". A redirect must contain a name or path. This will break in production.`);\r\n                throw new Error('Invalid redirect');\r\n            }\r\n            return assign({\r\n                query: to.query,\r\n                hash: to.hash,\r\n                params: to.params,\r\n            }, newTargetLocation);\r\n        }\r\n    }\r\n    function pushWithRedirect(to, redirectedFrom) {\r\n        const targetLocation = (pendingLocation = resolve(to));\r\n        const from = currentRoute.value;\r\n        const data = to.state;\r\n        const force = to.force;\r\n        // to could be a string where `replace` is a function\r\n        const replace = to.replace === true;\r\n        const shouldRedirect = handleRedirectRecord(targetLocation);\r\n        if (shouldRedirect)\r\n            return pushWithRedirect(assign(locationAsObject(shouldRedirect), {\r\n                state: data,\r\n                force,\r\n                replace,\r\n            }), \r\n            // keep original redirectedFrom if it exists\r\n            redirectedFrom || targetLocation);\r\n        // if it was a redirect we already called `pushWithRedirect` above\r\n        const toLocation = targetLocation;\r\n        toLocation.redirectedFrom = redirectedFrom;\r\n        let failure;\r\n        if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {\r\n            failure = createRouterError(16 /* NAVIGATION_DUPLICATED */, { to: toLocation, from });\r\n            // trigger scroll to allow scrolling to the same anchor\r\n            handleScroll(from, from, \r\n            // this is a push, the only way for it to be triggered from a\r\n            // history.listen is with a redirect, which makes it become a push\r\n            true, \r\n            // This cannot be the first navigation because the initial location\r\n            // cannot be manually navigated to\r\n            false);\r\n        }\r\n        return (failure ? Promise.resolve(failure) : navigate(toLocation, from))\r\n            .catch((error) => isNavigationFailure(error)\r\n            ? // navigation redirects still mark the router as ready\r\n                isNavigationFailure(error, 2 /* NAVIGATION_GUARD_REDIRECT */)\r\n                    ? error\r\n                    : markAsReady(error) // also returns the error\r\n            : // reject any unknown error\r\n                triggerError(error, toLocation, from))\r\n            .then((failure) => {\r\n            if (failure) {\r\n                if (isNavigationFailure(failure, 2 /* NAVIGATION_GUARD_REDIRECT */)) {\r\n                    if ((process.env.NODE_ENV !== 'production') &&\r\n                        // we are redirecting to the same location we were already at\r\n                        isSameRouteLocation(stringifyQuery$1, resolve(failure.to), toLocation) &&\r\n                        // and we have done it a couple of times\r\n                        redirectedFrom &&\r\n                        // @ts-expect-error: added only in dev\r\n                        (redirectedFrom._count = redirectedFrom._count\r\n                            ? // @ts-expect-error\r\n                                redirectedFrom._count + 1\r\n                            : 1) > 10) {\r\n                        warn(`Detected an infinite redirection in a navigation guard when going from \"${from.fullPath}\" to \"${toLocation.fullPath}\". Aborting to avoid a Stack Overflow. This will break in production if not fixed.`);\r\n                        return Promise.reject(new Error('Infinite redirect in navigation guard'));\r\n                    }\r\n                    return pushWithRedirect(\r\n                    // keep options\r\n                    assign(locationAsObject(failure.to), {\r\n                        state: data,\r\n                        force,\r\n                        replace,\r\n                    }), \r\n                    // preserve the original redirectedFrom if any\r\n                    redirectedFrom || toLocation);\r\n                }\r\n            }\r\n            else {\r\n                // if we fail we don't finalize the navigation\r\n                failure = finalizeNavigation(toLocation, from, true, replace, data);\r\n            }\r\n            triggerAfterEach(toLocation, from, failure);\r\n            return failure;\r\n        });\r\n    }\r\n    /**\r\n     * Helper to reject and skip all navigation guards if a new navigation happened\r\n     * @param to\r\n     * @param from\r\n     */\r\n    function checkCanceledNavigationAndReject(to, from) {\r\n        const error = checkCanceledNavigation(to, from);\r\n        return error ? Promise.reject(error) : Promise.resolve();\r\n    }\r\n    // TODO: refactor the whole before guards by internally using router.beforeEach\r\n    function navigate(to, from) {\r\n        let guards;\r\n        const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);\r\n        // all components here have been resolved once because we are leaving\r\n        guards = extractComponentsGuards(leavingRecords.reverse(), 'beforeRouteLeave', to, from);\r\n        // leavingRecords is already reversed\r\n        for (const record of leavingRecords) {\r\n            record.leaveGuards.forEach(guard => {\r\n                guards.push(guardToPromiseFn(guard, to, from));\r\n            });\r\n        }\r\n        const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);\r\n        guards.push(canceledNavigationCheck);\r\n        // run the queue of per route beforeRouteLeave guards\r\n        return (runGuardQueue(guards)\r\n            .then(() => {\r\n            // check global guards beforeEach\r\n            guards = [];\r\n            for (const guard of beforeGuards.list()) {\r\n                guards.push(guardToPromiseFn(guard, to, from));\r\n            }\r\n            guards.push(canceledNavigationCheck);\r\n            return runGuardQueue(guards);\r\n        })\r\n            .then(() => {\r\n            // check in components beforeRouteUpdate\r\n            guards = extractComponentsGuards(updatingRecords, 'beforeRouteUpdate', to, from);\r\n            for (const record of updatingRecords) {\r\n                record.updateGuards.forEach(guard => {\r\n                    guards.push(guardToPromiseFn(guard, to, from));\r\n                });\r\n            }\r\n            guards.push(canceledNavigationCheck);\r\n            // run the queue of per route beforeEnter guards\r\n            return runGuardQueue(guards);\r\n        })\r\n            .then(() => {\r\n            // check the route beforeEnter\r\n            guards = [];\r\n            for (const record of to.matched) {\r\n                // do not trigger beforeEnter on reused views\r\n                if (record.beforeEnter && !from.matched.includes(record)) {\r\n                    if (Array.isArray(record.beforeEnter)) {\r\n                        for (const beforeEnter of record.beforeEnter)\r\n                            guards.push(guardToPromiseFn(beforeEnter, to, from));\r\n                    }\r\n                    else {\r\n                        guards.push(guardToPromiseFn(record.beforeEnter, to, from));\r\n                    }\r\n                }\r\n            }\r\n            guards.push(canceledNavigationCheck);\r\n            // run the queue of per route beforeEnter guards\r\n            return runGuardQueue(guards);\r\n        })\r\n            .then(() => {\r\n            // NOTE: at this point to.matched is normalized and does not contain any () => Promise<Component>\r\n            // clear existing enterCallbacks, these are added by extractComponentsGuards\r\n            to.matched.forEach(record => (record.enterCallbacks = {}));\r\n            // check in-component beforeRouteEnter\r\n            guards = extractComponentsGuards(enteringRecords, 'beforeRouteEnter', to, from);\r\n            guards.push(canceledNavigationCheck);\r\n            // run the queue of per route beforeEnter guards\r\n            return runGuardQueue(guards);\r\n        })\r\n            .then(() => {\r\n            // check global guards beforeResolve\r\n            guards = [];\r\n            for (const guard of beforeResolveGuards.list()) {\r\n                guards.push(guardToPromiseFn(guard, to, from));\r\n            }\r\n            guards.push(canceledNavigationCheck);\r\n            return runGuardQueue(guards);\r\n        })\r\n            // catch any navigation canceled\r\n            .catch(err => isNavigationFailure(err, 8 /* NAVIGATION_CANCELLED */)\r\n            ? err\r\n            : Promise.reject(err)));\r\n    }\r\n    function triggerAfterEach(to, from, failure) {\r\n        // navigation is confirmed, call afterGuards\r\n        // TODO: wrap with error handlers\r\n        for (const guard of afterGuards.list())\r\n            guard(to, from, failure);\r\n    }\r\n    /**\r\n     * - Cleans up any navigation guards\r\n     * - Changes the url if necessary\r\n     * - Calls the scrollBehavior\r\n     */\r\n    function finalizeNavigation(toLocation, from, isPush, replace, data) {\r\n        // a more recent navigation took place\r\n        const error = checkCanceledNavigation(toLocation, from);\r\n        if (error)\r\n            return error;\r\n        // only consider as push if it's not the first navigation\r\n        const isFirstNavigation = from === START_LOCATION_NORMALIZED;\r\n        const state = !isBrowser ? {} : history.state;\r\n        // change URL only if the user did a push/replace and if it's not the initial navigation because\r\n        // it's just reflecting the url\r\n        if (isPush) {\r\n            // on the initial navigation, we want to reuse the scroll position from\r\n            // history state if it exists\r\n            if (replace || isFirstNavigation)\r\n                routerHistory.replace(toLocation.fullPath, assign({\r\n                    scroll: isFirstNavigation && state && state.scroll,\r\n                }, data));\r\n            else\r\n                routerHistory.push(toLocation.fullPath, data);\r\n        }\r\n        // accept current navigation\r\n        currentRoute.value = toLocation;\r\n        handleScroll(toLocation, from, isPush, isFirstNavigation);\r\n        markAsReady();\r\n    }\r\n    let removeHistoryListener;\r\n    // attach listener to history to trigger navigations\r\n    function setupListeners() {\r\n        removeHistoryListener = routerHistory.listen((to, _from, info) => {\r\n            // cannot be a redirect route because it was in history\r\n            const toLocation = resolve(to);\r\n            // due to dynamic routing, and to hash history with manual navigation\r\n            // (manually changing the url or calling history.hash = '#/somewhere'),\r\n            // there could be a redirect record in history\r\n            const shouldRedirect = handleRedirectRecord(toLocation);\r\n            if (shouldRedirect) {\r\n                pushWithRedirect(assign(shouldRedirect, { replace: true }), toLocation).catch(noop);\r\n                return;\r\n            }\r\n            pendingLocation = toLocation;\r\n            const from = currentRoute.value;\r\n            // TODO: should be moved to web history?\r\n            if (isBrowser) {\r\n                saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());\r\n            }\r\n            navigate(toLocation, from)\r\n                .catch((error) => {\r\n                if (isNavigationFailure(error, 4 /* NAVIGATION_ABORTED */ | 8 /* NAVIGATION_CANCELLED */)) {\r\n                    return error;\r\n                }\r\n                if (isNavigationFailure(error, 2 /* NAVIGATION_GUARD_REDIRECT */)) {\r\n                    // Here we could call if (info.delta) routerHistory.go(-info.delta,\r\n                    // false) but this is bug prone as we have no way to wait the\r\n                    // navigation to be finished before calling pushWithRedirect. Using\r\n                    // a setTimeout of 16ms seems to work but there is not guarantee for\r\n                    // it to work on every browser. So Instead we do not restore the\r\n                    // history entry and trigger a new navigation as requested by the\r\n                    // navigation guard.\r\n                    // the error is already handled by router.push we just want to avoid\r\n                    // logging the error\r\n                    pushWithRedirect(error.to, toLocation\r\n                    // avoid an uncaught rejection, let push call triggerError\r\n                    )\r\n                        .then(failure => {\r\n                        // manual change in hash history #916 ending up in the URL not\r\n                        // changing but it was changed by the manual url change, so we\r\n                        // need to manually change it ourselves\r\n                        if (isNavigationFailure(failure, 4 /* NAVIGATION_ABORTED */ |\r\n                            16 /* NAVIGATION_DUPLICATED */) &&\r\n                            !info.delta &&\r\n                            info.type === NavigationType.pop) {\r\n                            routerHistory.go(-1, false);\r\n                        }\r\n                    })\r\n                        .catch(noop);\r\n                    // avoid the then branch\r\n                    return Promise.reject();\r\n                }\r\n                // do not restore history on unknown direction\r\n                if (info.delta)\r\n                    routerHistory.go(-info.delta, false);\r\n                // unrecognized error, transfer to the global handler\r\n                return triggerError(error, toLocation, from);\r\n            })\r\n                .then((failure) => {\r\n                failure =\r\n                    failure ||\r\n                        finalizeNavigation(\r\n                        // after navigation, all matched components are resolved\r\n                        toLocation, from, false);\r\n                // revert the navigation\r\n                if (failure) {\r\n                    if (info.delta) {\r\n                        routerHistory.go(-info.delta, false);\r\n                    }\r\n                    else if (info.type === NavigationType.pop &&\r\n                        isNavigationFailure(failure, 4 /* NAVIGATION_ABORTED */ | 16 /* NAVIGATION_DUPLICATED */)) {\r\n                        // manual change in hash history #916\r\n                        // it's like a push but lacks the information of the direction\r\n                        routerHistory.go(-1, false);\r\n                    }\r\n                }\r\n                triggerAfterEach(toLocation, from, failure);\r\n            })\r\n                .catch(noop);\r\n        });\r\n    }\r\n    // Initialization and Errors\r\n    let readyHandlers = useCallbacks();\r\n    let errorHandlers = useCallbacks();\r\n    let ready;\r\n    /**\r\n     * Trigger errorHandlers added via onError and throws the error as well\r\n     *\r\n     * @param error - error to throw\r\n     * @param to - location we were navigating to when the error happened\r\n     * @param from - location we were navigating from when the error happened\r\n     * @returns the error as a rejected promise\r\n     */\r\n    function triggerError(error, to, from) {\r\n        markAsReady(error);\r\n        const list = errorHandlers.list();\r\n        if (list.length) {\r\n            list.forEach(handler => handler(error, to, from));\r\n        }\r\n        else {\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                warn('uncaught error during route navigation:');\r\n            }\r\n            console.error(error);\r\n        }\r\n        return Promise.reject(error);\r\n    }\r\n    function isReady() {\r\n        if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)\r\n            return Promise.resolve();\r\n        return new Promise((resolve, reject) => {\r\n            readyHandlers.add([resolve, reject]);\r\n        });\r\n    }\r\n    function markAsReady(err) {\r\n        if (!ready) {\r\n            // still not ready if an error happened\r\n            ready = !err;\r\n            setupListeners();\r\n            readyHandlers\r\n                .list()\r\n                .forEach(([resolve, reject]) => (err ? reject(err) : resolve()));\r\n            readyHandlers.reset();\r\n        }\r\n        return err;\r\n    }\r\n    // Scroll behavior\r\n    function handleScroll(to, from, isPush, isFirstNavigation) {\r\n        const { scrollBehavior } = options;\r\n        if (!isBrowser || !scrollBehavior)\r\n            return Promise.resolve();\r\n        const scrollPosition = (!isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0))) ||\r\n            ((isFirstNavigation || !isPush) &&\r\n                history.state &&\r\n                history.state.scroll) ||\r\n            null;\r\n        return nextTick()\r\n            .then(() => scrollBehavior(to, from, scrollPosition))\r\n            .then(position => position && scrollToPosition(position))\r\n            .catch(err => triggerError(err, to, from));\r\n    }\r\n    const go = (delta) => routerHistory.go(delta);\r\n    let started;\r\n    const installedApps = new Set();\r\n    const router = {\r\n        currentRoute,\r\n        addRoute,\r\n        removeRoute,\r\n        hasRoute,\r\n        getRoutes,\r\n        resolve,\r\n        options,\r\n        push,\r\n        replace,\r\n        go,\r\n        back: () => go(-1),\r\n        forward: () => go(1),\r\n        beforeEach: beforeGuards.add,\r\n        beforeResolve: beforeResolveGuards.add,\r\n        afterEach: afterGuards.add,\r\n        onError: errorHandlers.add,\r\n        isReady,\r\n        install(app) {\r\n            const router = this;\r\n            app.component('RouterLink', RouterLink);\r\n            app.component('RouterView', RouterView);\r\n            app.config.globalProperties.$router = router;\r\n            Object.defineProperty(app.config.globalProperties, '$route', {\r\n                enumerable: true,\r\n                get: () => unref(currentRoute),\r\n            });\r\n            // this initial navigation is only necessary on client, on server it doesn't\r\n            // make sense because it will create an extra unnecessary navigation and could\r\n            // lead to problems\r\n            if (isBrowser &&\r\n                // used for the initial navigation client side to avoid pushing\r\n                // multiple times when the router is used in multiple apps\r\n                !started &&\r\n                currentRoute.value === START_LOCATION_NORMALIZED) {\r\n                // see above\r\n                started = true;\r\n                push(routerHistory.location).catch(err => {\r\n                    if ((process.env.NODE_ENV !== 'production'))\r\n                        warn('Unexpected error when starting the router:', err);\r\n                });\r\n            }\r\n            const reactiveRoute = {};\r\n            for (const key in START_LOCATION_NORMALIZED) {\r\n                // @ts-expect-error: the key matches\r\n                reactiveRoute[key] = computed(() => currentRoute.value[key]);\r\n            }\r\n            app.provide(routerKey, router);\r\n            app.provide(routeLocationKey, reactive(reactiveRoute));\r\n            app.provide(routerViewLocationKey, currentRoute);\r\n            const unmountApp = app.unmount;\r\n            installedApps.add(app);\r\n            app.unmount = function () {\r\n                installedApps.delete(app);\r\n                // the router is not attached to an app anymore\r\n                if (installedApps.size < 1) {\r\n                    // invalidate the current navigation\r\n                    pendingLocation = START_LOCATION_NORMALIZED;\r\n                    removeHistoryListener && removeHistoryListener();\r\n                    currentRoute.value = START_LOCATION_NORMALIZED;\r\n                    started = false;\r\n                    ready = false;\r\n                }\r\n                unmountApp();\r\n            };\r\n            if (((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) && isBrowser) {\r\n                addDevtools(app, router, matcher);\r\n            }\r\n        },\r\n    };\r\n    return router;\r\n}\r\nfunction runGuardQueue(guards) {\r\n    return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());\r\n}\r\nfunction extractChangingRecords(to, from) {\r\n    const leavingRecords = [];\r\n    const updatingRecords = [];\r\n    const enteringRecords = [];\r\n    const len = Math.max(from.matched.length, to.matched.length);\r\n    for (let i = 0; i < len; i++) {\r\n        const recordFrom = from.matched[i];\r\n        if (recordFrom) {\r\n            if (to.matched.find(record => isSameRouteRecord(record, recordFrom)))\r\n                updatingRecords.push(recordFrom);\r\n            else\r\n                leavingRecords.push(recordFrom);\r\n        }\r\n        const recordTo = to.matched[i];\r\n        if (recordTo) {\r\n            // the type doesn't matter because we are comparing per reference\r\n            if (!from.matched.find(record => isSameRouteRecord(record, recordTo))) {\r\n                enteringRecords.push(recordTo);\r\n            }\r\n        }\r\n    }\r\n    return [leavingRecords, updatingRecords, enteringRecords];\r\n}\n\n/**\r\n * Returns the router instance. Equivalent to using `$router` inside\r\n * templates.\r\n */\r\nfunction useRouter() {\r\n    return inject(routerKey);\r\n}\r\n/**\r\n * Returns the current route location. Equivalent to using `$route` inside\r\n * templates.\r\n */\r\nfunction useRoute() {\r\n    return inject(routeLocationKey);\r\n}\n\nexport { NavigationFailureType, RouterLink, RouterView, START_LOCATION_NORMALIZED as START_LOCATION, createMemoryHistory, createRouter, createRouterMatcher, createWebHashHistory, createWebHistory, isNavigationFailure, matchedRouteKey, onBeforeRouteLeave, onBeforeRouteUpdate, parseQuery, routeLocationKey, routerKey, routerViewLocationKey, stringifyQuery, useLink, useRoute, useRouter, viewDepthKey };\n","import { getTarget, getDevtoolsGlobalHook, isProxyAvailable } from './env';\nimport { HOOK_SETUP } from './const';\nimport { ApiProxy } from './proxy';\nexport * from './api';\nexport * from './plugin';\nexport * from './time';\nexport function setupDevtoolsPlugin(pluginDescriptor, setupFn) {\n    const descriptor = pluginDescriptor;\n    const target = getTarget();\n    const hook = getDevtoolsGlobalHook();\n    const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;\n    if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {\n        hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);\n    }\n    else {\n        const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;\n        const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];\n        list.push({\n            pluginDescriptor: descriptor,\n            setupFn,\n            proxy,\n        });\n        if (proxy)\n            setupFn(proxy.proxiedTarget);\n    }\n}\n"],"names":["getTarget","navigator","window","global","isProxyAvailable","Proxy","supported","perf","ApiProxy","constructor","plugin","hook","this","target","targetQueue","onQueue","defaultSettings","settings","id","item","defaultValue","localSettingsSaveId","currentSettings","Object","assign","raw","localStorage","getItem","data","JSON","parse","e","fallbacks","getSettings","setSettings","value","setItem","stringify","now","undefined","performance","Date","on","pluginId","proxiedOn","get","_target","prop","args","push","method","proxiedTarget","keys","includes","resolve","Promise","hasSymbol","Symbol","toStringTag","PolySymbol","name","matchedRouteKey","viewDepthKey","routerKey","routeLocationKey","routerViewLocationKey","isBrowser","applyToParams","fn","params","newParams","key","Array","isArray","map","noop","TRAILING_SLASH_RE","parseURL","parseQuery","location","currentLocation","path","query","searchString","hash","searchPos","indexOf","hashPos","slice","length","to","from","startsWith","fromSegments","split","toSegments","toPosition","segment","position","join","resolveRelativePath","fullPath","stripBase","pathname","base","toLowerCase","isSameRouteRecord","a","b","aliasOf","isSameRouteLocationParams","isSameRouteLocationParamsValue","isEquivalentArray","every","i","NavigationType","NavigationDirection","normalizeBase","baseEl","document","querySelector","getAttribute","replace","BEFORE_HASH_RE","createHref","computeScrollPosition","left","pageXOffset","top","pageYOffset","getScrollKey","delta","history","state","scrollPositions","Map","createBaseLocation","protocol","host","createCurrentLocation","search","slicePos","pathFromHash","buildState","back","current","forward","replaced","computeScroll","scroll","createWebHistory","historyNavigation","historyState","changeLocation","hashIndex","url","err","console","error","currentState","useHistoryStateNavigation","historyListeners","listeners","teardowns","pauseState","popStateHandler","fromState","forEach","listener","type","pop","direction","unknown","beforeUnloadListener","replaceState","addEventListener","pauseListeners","listen","callback","teardown","index","splice","destroy","removeEventListener","useHistoryListeners","routerHistory","go","triggerListeners","bind","defineProperty","enumerable","createMemoryHistory","queue","setLocation","shouldTrigger","Math","max","min","info","createWebHashHistory","isRouteName","START_LOCATION_NORMALIZED","matched","meta","redirectedFrom","NavigationFailureSymbol","NavigationFailureType","createRouterError","Error","isNavigationFailure","BASE_PARAM_PATTERN","BASE_PATH_PARSER_OPTIONS","sensitive","strict","start","end","REGEX_CHARS_RE","compareScoreArray","diff","comparePathParserScore","aScore","score","bScore","comp","ROOT_TOKEN","VALID_PARAM_RE","createRouteRecordMatcher","record","parent","options","parser","segments","extraOptions","pattern","segmentScores","tokenIndex","token","subSegmentScore","repeatable","optional","regexp","re","RegExp","message","subPattern","match","avoidDuplicatedSlash","endsWith","param","text","tokensToParser","crash","buffer","previousState","tokens","finalizeSegment","char","customRe","consumeBuffer","addCharToBuffer","test","tokenizePath","matcher","children","alias","createRouterMatcher","routes","globalOptions","matchers","matcherMap","addRoute","originalRecord","isRootAdd","mainNormalizedRecord","redirect","beforeEnter","props","normalizeRecordProps","instances","leaveGuards","Set","updateGuards","enterCallbacks","components","default","component","normalizeRouteRecord","mergeOptions","normalizedRecords","aliases","originalMatcher","normalizedRecord","parentPath","connectingSlash","isAliasRecord","removeRoute","insertMatcher","matcherRef","delete","isRecordChildOf","set","route","paramsFromLocation","filter","k","find","m","parentMatcher","unshift","mergeMetaFields","getRoutes","getRecordMatcher","propsObject","reduce","defaults","partialOptions","some","child","HASH_RE","AMPERSAND_RE","SLASH_RE","EQUAL_RE","IM_RE","PLUS_RE","ENC_BRACKET_OPEN_RE","ENC_BRACKET_CLOSE_RE","ENC_CARET_RE","ENC_BACKTICK_RE","ENC_CURLY_OPEN_RE","ENC_PIPE_RE","ENC_CURLY_CLOSE_RE","ENC_SPACE_RE","commonEncode","encodeURI","encodeQueryValue","encodeParam","encodePath","decode","decodeURIComponent","searchParams","searchParam","eqPos","currentValue","stringifyQuery","v","normalizeQuery","normalizedQuery","useCallbacks","handlers","add","handler","list","reset","registerGuard","guard","removeFromList","onUnmounted","onDeactivated","onActivated","onBeforeRouteLeave","leaveGuard","activeRecord","inject","onBeforeRouteUpdate","updateGuard","guardToPromiseFn","enterCallbackArray","reject","next","valid","guardReturn","call","guardCall","then","catch","extractComponentsGuards","guardType","guards","rawComponent","__vccOpts","componentPromise","resolved","resolvedComponent","obj","__esModule","useLink","router","currentRoute","computed","unref","activeRecordIndex","routeMatched","currentMatched","findIndex","parentRecordPath","getOriginalPath","isActive","outer","inner","innerValue","outerValue","includesParams","isExactActive","__VUE_PROD_DEVTOOLS__","instance","getCurrentInstance","linkContextDevtools","__vrl_devtools","watchEffect","flush","href","navigate","metaKey","altKey","ctrlKey","shiftKey","defaultPrevented","button","currentTarget","preventDefault","guardEvent","RouterLink","defineComponent","String","required","Boolean","activeClass","exactActiveClass","custom","ariaCurrentValue","setup","slots","link","reactive","elClass","getLinkClass","linkActiveClass","linkExactActiveClass","h","onClick","class","propClass","globalClass","defaultClass","normalizeSlot","slot","slotContent","RouterView","inheritAttrs","attrs","injectedRoute","routeToDisplay","depth","matchedRouteRef","provide","viewRef","ref","watch","oldInstance","oldName","size","matchedRoute","ViewComponent","currentName","Component","routePropsOption","routeProps","onVnodeUnmounted","vnode","isUnmounted","r","__vrv_devtools","formatRouteLocation","routeLocation","tooltip","copy","ret","omit","_custom","readOnly","display","formatDisplay","routerId","addDevtools","app","__hasDevtools","pluginDescriptor","setupFn","descriptor","__VUE_DEVTOOLS_GLOBAL_HOOK__","enableProxy","enableEarlyProxy","__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__","proxy","__VUE_DEVTOOLS_PLUGINS__","emit","setupDevtoolsPlugin","label","packageName","homepage","logo","componentStateTypes","api","inspectComponent","payload","ctx","instanceData","editable","visitComponentTree","treeNode","node","componentInstance","tags","toString","textColor","backgroundColor","PINK_500","__devtoolsApi","devtoolsData","ORANGE_400","LIME_500","BLUE_600","refreshRoutesView","notifyComponentUpdate","sendInspectorTree","routerInspectorId","sendInspectorState","navigationsLayerId","addTimelineLayer","color","onError","addTimelineEvent","layerId","event","title","subtitle","logType","time","groupId","__navigationId","navigationId","beforeEach","afterEach","failure","status","activeRoutesPayload","resetMatchStateOnRouteRecord","isRouteMatching","markRouteRecordActive","rootNodes","formatRouteRecordForInspector","addInspector","icon","treeFilterPlaceholder","getInspectorTree","inspectorId","getInspectorState","__vd_id","nodeId","formatRouteRecordMatcherForStateInspector","fields","modifierForKey","__vd_match","__vd_exactActive","__vd_active","routeRecordId","EXTRACT_REGEXP_RE","childRoute","found","decodedPath","createRouter","parseQuery$1","stringifyQuery$1","beforeGuards","beforeResolveGuards","afterGuards","shallowRef","pendingLocation","scrollBehavior","scrollRestoration","normalizeParams","paramValue","encodeParams","decodeParams","rawLocation","locationNormalized","matcherLocation","targetParams","stringifyURL","locationAsObject","checkCanceledNavigation","pushWithRedirect","handleRedirectRecord","lastMatched","newTargetLocation","targetLocation","force","shouldRedirect","toLocation","aLastIndex","bLastIndex","isSameRouteLocation","handleScroll","markAsReady","triggerError","finalizeNavigation","triggerAfterEach","checkCanceledNavigationAndReject","leavingRecords","updatingRecords","enteringRecords","len","recordFrom","recordTo","extractChangingRecords","reverse","canceledNavigationCheck","runGuardQueue","isPush","isFirstNavigation","removeHistoryListener","ready","readyHandlers","errorHandlers","_from","scrollPosition","getSavedScrollPosition","nextTick","scrollToOptions","positionEl","el","isIdSelector","getElementById","offset","docRect","documentElement","getBoundingClientRect","elRect","behavior","getElementPosition","style","scrollTo","scrollToPosition","started","installedApps","parentOrRoute","recordMatcher","hasRoute","routeMatcher","beforeResolve","isReady","install","config","globalProperties","$router","reactiveRoute","unmountApp","unmount","promise","useRouter","useRoute"],"sourceRoot":""}